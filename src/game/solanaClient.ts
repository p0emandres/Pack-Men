import { Buffer } from 'buffer'
import { PublicKey, Connection, Transaction, VersionedTransaction, SystemProgram, TransactionInstruction } from '@solana/web3.js'
import { Program, AnchorProvider, Wallet, BN, Idl, utils } from '@coral-xyz/anchor'
import { 
  TOKEN_PROGRAM_ID, 
  ASSOCIATED_TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  getAccount,
} from '@solana/spl-token'
// Import the natively generated IDL from Anchor build
// This IDL is automatically generated by 'anchor build' at target/idl/droog_game.json
// It includes proper discriminators and is the source of truth for the program interface
import DroogGameIDL from '../../target/idl/droog_game.json'
import { getCurrentMatchTime } from './timeUtils'
import { hashMatchIdStringToBytes, hashToU64 } from './matchIdHash'
import { createMatchIdentity, u64ToLE, assertBuffer } from './matchIdentity'
import { sortPlayerPubkeys } from './matchCoordination'

// =============================================================================
// RPC Request Throttle - Prevents 429 rate limiting from public RPC endpoints
// =============================================================================
class RpcThrottle {
  private queue: Array<{ resolve: () => void }> = []
  private lastRequestTime = 0
  private processing = false
  private minDelayMs: number

  constructor(minDelayMs = 100) {
    this.minDelayMs = minDelayMs
  }

  async acquire(): Promise<void> {
    return new Promise((resolve) => {
      this.queue.push({ resolve })
      this.processQueue()
    })
  }

  private async processQueue() {
    if (this.processing || this.queue.length === 0) return
    this.processing = true

    while (this.queue.length > 0) {
      const now = Date.now()
      const elapsed = now - this.lastRequestTime
      const waitTime = Math.max(0, this.minDelayMs - elapsed)
      
      if (waitTime > 0) {
        await new Promise(r => setTimeout(r, waitTime))
      }
      
      this.lastRequestTime = Date.now()
      const item = this.queue.shift()
      item?.resolve()
    }

    this.processing = false
  }
}

// Singleton throttle instance - 300ms between requests = max 3.3 requests/second
// Very conservative rate to prevent 429 errors from Helius free tier
// Privy's embedded wallet also makes RPC calls during transaction preparation
const rpcThrottle = new RpcThrottle(300)

// Export for use in other modules that make RPC calls
export { rpcThrottle }

// Verify the IDL has discriminators (Anchor 0.32+ includes them automatically)
if (DroogGameIDL.instructions?.[0]?.discriminator) {
  console.log('[DroogGameClient] ✓ Using natively generated Anchor IDL with discriminators')
} else {
  console.warn('[DroogGameClient] ⚠️ IDL missing discriminators - this should not happen with Anchor 0.32+')
}

/**
 * Compute Anchor discriminator for an instruction or account.
 * Anchor uses SHA256("global:{name}") for instructions and SHA256("account:{name}") for accounts.
 * Returns the first 8 bytes as a Buffer.
 */
async function computeDiscriminator(prefix: 'global' | 'account', name: string): Promise<Buffer> {
  const encoder = new TextEncoder()
  const data = encoder.encode(`${prefix}:${name}`)
  const hashBuffer = await crypto.subtle.digest('SHA-256', data)
  const hash = Buffer.from(hashBuffer)
  // Return first 8 bytes
  return hash.subarray(0, 8)
}

/**
 * Deep clone function that preserves object structure and type references.
 * This is critical for IDL normalization - JSON.parse(JSON.stringify()) can
 * corrupt type references in arrays like ['CustomerState', 23].
 */
function deepCloneIdl(obj: any, visited = new WeakMap()): any {
  // Handle primitives and null
  if (obj === null || typeof obj !== 'object') {
    return obj
  }
  
  // Handle circular references
  if (visited.has(obj)) {
    return visited.get(obj)
  }
  
  // Handle Buffer (preserve as-is, don't clone)
  if (Buffer.isBuffer(obj)) {
    return obj
  }
  
  // Handle arrays
  if (Array.isArray(obj)) {
    const cloned: any[] = []
    visited.set(obj, cloned)
    for (let i = 0; i < obj.length; i++) {
      cloned[i] = deepCloneIdl(obj[i], visited)
    }
    return cloned
  }
  
  // Handle objects
  const cloned: any = {}
  visited.set(obj, cloned)
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      cloned[key] = deepCloneIdl(obj[key], visited)
    }
  }
  return cloned
}

/**
 * Normalize IDL by adding discriminators to instructions and accounts.
 * This is required because Anchor expects Buffer discriminators, not strings.
 * 
 * @param idl - The IDL object (may be missing discriminators)
 * @returns Normalized IDL with Buffer discriminators
 */
/**
 * Normalize option types to ensure they're in the format Anchor expects.
 * Anchor's type resolver can corrupt option types during resolution, so we
 * need to ensure they're in the correct format before passing to Anchor.
 */
function normalizeOptionTypes(idl: any): void {
  // Transform IDL types to match Anchor's TypeScript IdlType schema
  // Reference: ts/packages/anchor/src/idl.ts
  
  function normalizeType(type: any): any {
    if (!type || typeof type !== 'object') {
      // Handle string primitives
      if (type === 'publicKey' || type === 'pubKey') {
        return 'pubkey'  // Anchor expects lowercase "pubkey"
      }
      return type
    }
    
    // Handle option types: { option: IdlType }
    if ('option' in type) {
      let innerType = type.option
      
      // Recursively normalize the inner type
      if (typeof innerType === 'object' && innerType !== null) {
        return { option: normalizeType(innerType) }
      }
      
      // Convert publicKey/pubKey to pubkey
      if (innerType === 'publicKey' || innerType === 'pubKey') {
        innerType = 'pubkey'
      }
      
      return { option: innerType }
    }
    
    // Handle defined types: must be { defined: { name: string } }
    if ('defined' in type) {
      const definedValue = type.defined
      
      // If it's a string, wrap it in the correct structure
      if (typeof definedValue === 'string') {
        return { defined: { name: definedValue } }
      }
      
      // If it's already an object, ensure it has the name property
      if (typeof definedValue === 'object' && definedValue !== null) {
        return { defined: definedValue }
      }
    }
    
    // Handle array types: { array: [IdlType, size] }
    if ('array' in type && Array.isArray(type.array)) {
      const [innerType, size] = type.array
      return { array: [normalizeType(innerType), size] }
    }
    
    // Handle vec types
    if ('vec' in type) {
      return { vec: normalizeType(type.vec) }
    }
    
    return type
  }
  
  function normalizeFields(fields: any[]): void {
    if (!Array.isArray(fields)) return
    
    fields.forEach(field => {
      if (field.type) {
        field.type = normalizeType(field.type)
      }
    })
  }
  
  // Normalize accounts
  if (idl.accounts) {
    idl.accounts.forEach((account: any) => {
      // Handle both formats: with kind: 'struct' and without
      if (account.type?.fields) {
        normalizeFields(account.type.fields)
      }
    })
  }
  
  // Normalize types
  if (idl.types) {
    idl.types.forEach((type: any) => {
      // Handle both formats: with kind: 'struct' and without
      if (type.type?.fields) {
        normalizeFields(type.type.fields)
      }
      if (type.type?.kind === 'enum' && type.type.variants) {
        type.type.variants.forEach((variant: any) => {
          if (variant.fields) {
            normalizeFields(variant.fields)
          }
        })
      }
    })
  }
  
  // Normalize instructions
  if (idl.instructions) {
    idl.instructions.forEach((ix: any) => {
      if (ix.args) {
        normalizeFields(ix.args)
      }
    })
  }
  
  // Normalize events
  if (idl.events) {
    idl.events.forEach((event: any) => {
      if (event.fields) {
        normalizeFields(event.fields)
      }
    })
  }
}

async function normalizeIdl(idl: any): Promise<any> {
  // CRITICAL: After fixing the IDL array format to use { defined: 'TypeName' },
  // we can now safely add discriminators. The key is to preserve all object
  // references, especially for the types array which Anchor uses for resolution.
  //
  // Strategy: Only modify instruction/account objects that need discriminators,
  // and preserve everything else as original references.
  
  // FIRST: Normalize option types to ensure they're in the correct format
  // This must happen before adding discriminators
  normalizeOptionTypes(idl)
  
  // Check if discriminators are already present
  const needsNormalization = 
    (idl.instructions?.some((inst: any) => !inst.discriminator || !Buffer.isBuffer(inst.discriminator))) ||
    (idl.accounts?.some((acc: any) => !acc.discriminator || !Buffer.isBuffer(acc.discriminator)))
  
  if (!needsNormalization) {
    // IDL already has discriminators, return as-is (but option types are normalized)
    return idl
  }
  
  // Create minimal copy - preserve all references except where we add discriminators
  const normalized: any = {
    ...idl,
    // Preserve original arrays - we'll only modify individual items
    instructions: idl.instructions,
    accounts: idl.accounts,
    types: idl.types, // CRITICAL: Keep exact same reference
    events: idl.events,
    errors: idl.errors,
  }
  
  // Add discriminators only where missing, modifying items in place
  // CRITICAL: Modify objects in-place to preserve all nested type references
  // Using spread operator creates new objects which breaks Anchor's type resolution
  if (normalized.instructions && Array.isArray(normalized.instructions)) {
    for (let i = 0; i < normalized.instructions.length; i++) {
      const inst = normalized.instructions[i]
      if (!inst.discriminator || !Buffer.isBuffer(inst.discriminator)) {
        // Add discriminator in-place to preserve all nested references
        inst.discriminator = await computeDiscriminator('global', inst.name)
      }
    }
  }
  
  if (normalized.accounts && Array.isArray(normalized.accounts)) {
    for (let i = 0; i < normalized.accounts.length; i++) {
      const acc = normalized.accounts[i]
      if (!acc.discriminator || !Buffer.isBuffer(acc.discriminator)) {
        // Add discriminator in-place to preserve all nested type references
        // This ensures Anchor's type resolver can find types like { defined: 'CustomerState' }
        acc.discriminator = await computeDiscriminator('account', acc.name)
      }
    }
  }
  
  // Types array must remain the exact same reference - Anchor uses it for type resolution
  // Do NOT modify or clone it
  
  return normalized
}

// Program ID - matches the deployed program on devnet
export const PROGRAM_ID = new PublicKey('2xzwRYwn1gdVBd5FBrvWV5To6qKR9pn9UfiJnZz8GwC2')

// =============================================================================
// $PACKS Token Staking Constants
// =============================================================================

// $PACKS token mint address (created via scripts/create-packs-mint.ts)
export const PACKS_MINT = new PublicKey('AGgb9HmTvGW6JWyfJZ4BzfLcNThPJb5H3WdhR4GXjzX6')

// Staking constants (must match on-chain)
export const STAKE_AMOUNT = 1_000_000 // 1 token with 6 decimals
export const BURN_PERCENTAGE = 10 // 10% burned at match activation
export const TOKEN_DECIMALS = 6
export const CANCEL_TIMEOUT_SECONDS = 300 // 5 minutes

// MatchStatus enum (from on-chain)
export type MatchStatus = 'pending' | 'active' | 'finalized' | 'cancelled'

export interface StakeState {
  matchId: BN
  matchIdHash: number[]
  playerA: PublicKey
  playerB: PublicKey
  status: MatchStatus
  playerAEscrowed: BN
  playerBEscrowed: BN
  createdAt: BN
  bump: number
  escrowBump: number
}

export interface MatchState {
  matchId: BN
  startTs: BN
  endTs: BN
  playerA: PublicKey
  playerB: PublicKey
  customers: CustomerState[]
  playerASales: number
  playerBSales: number
  playerAReputation: number
  playerBReputation: number
  isFinalized: boolean
}

export interface CustomerState {
  layer: number
  lastServedTs: BN
  totalServes: number
  lastServedBy: PublicKey | null
}

// PlantState enum from Anchor program
export type PlantState = 
  | { __kind: 'Empty' }
  | { __kind: 'Growing'; strainLevel: number; plantedAt: BN }
  | { __kind: 'Ready'; strainLevel: number }

export interface GrowSlot {
  // New structure (from chain)
  plantState: PlantState
  strainLevel: number
  variantId: number
  lastHarvestedTs: BN
  
  // Legacy fields (computed for backward compatibility)
  occupied: boolean
  plantedTs: BN
  readyTs: BN
  harvested: boolean
}

export interface Inventory {
  level1: number
  level2: number
  level3: number
}

export interface GrowState {
  matchId: BN
  playerA: PublicKey
  playerB: PublicKey
  playerASlots: GrowSlot[]
  playerBSlots: GrowSlot[]
  playerAInventory: Inventory
  playerBInventory: Inventory
}

export interface DeliveryState {
  matchId: BN
  lastUpdateTs: BN
  availableCustomers: number[]
  activeCount: number
}

// Growth times in seconds (matching on-chain constants)
// Fast-paced 10-minute match timing
export const GROWTH_TIMES = {
  1: 10,   // Level 1: 10 seconds
  2: 30,   // Level 2: 30 seconds
  3: 60,   // Level 3: 1 minute
} as const

// Smell rates per minute
export const SMELL_RATES = {
  1: 1,  // Level 1: +1 per minute
  2: 2,  // Level 2: +2 per minute
  3: 4,  // Level 3: +4 per minute
} as const

// Endgame lock: no planting in final 1 minute (adjusted for 10-minute matches)
export const ENDGAME_LOCK_SECONDS = 60

// Delivery rotation interval in seconds (matching on-chain)
export const DELIVERY_ROTATION_INTERVAL = 60

// Number of grow slots per player
export const SLOTS_PER_PLAYER = 6

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AnyProgram = Program<any>

// Cached normalized IDL promise (computed once, reused for all instances)
let normalizedIdlPromise: Promise<any> | null = null

/**
 * Get or create the normalized IDL with discriminators.
 * This is cached so subsequent calls return the same promise.
 * 
 * CRITICAL: Anchor's type resolver requires exact object structure.
 * The issue is that when Anchor processes option types, it expects { option: 'publicKey' }
 * but might be receiving just 'publicKey' if the structure is corrupted.
 */
function getNormalizedIdl(): Promise<any> {
  if (!normalizedIdlPromise) {
    // Native Anchor 0.32+ IDL has discriminators as arrays, not Buffers
    // Check if discriminators are present (either as arrays or Buffers)
    const firstInstruction = DroogGameIDL.instructions?.[0] as any
    const hasDiscriminators = 
      firstInstruction?.discriminator && 
      (Array.isArray(firstInstruction.discriminator) || Buffer.isBuffer(firstInstruction.discriminator))
    
    if (hasDiscriminators) {
      // Native Anchor IDL - convert array discriminators to Buffers if needed
      // Anchor's Program class can handle both formats, but we normalize to Buffers for consistency
      const idl = deepCloneIdl(DroogGameIDL)
      
      // Ensure the IDL address matches the actual program ID
      idl.address = PROGRAM_ID.toString()
      
      // Convert array discriminators to Buffers for instructions
      if (idl.instructions) {
        for (const inst of idl.instructions) {
          if (inst.discriminator && Array.isArray(inst.discriminator) && !Buffer.isBuffer(inst.discriminator)) {
            inst.discriminator = Buffer.from(inst.discriminator)
          }
        }
      }
      
      // Convert array discriminators to Buffers for accounts
      if (idl.accounts) {
        for (const acc of idl.accounts) {
          if (acc.discriminator && Array.isArray(acc.discriminator) && !Buffer.isBuffer(acc.discriminator)) {
            acc.discriminator = Buffer.from(acc.discriminator)
          }
        }
      }
      
      normalizedIdlPromise = Promise.resolve(idl)
    } else {
      // IDL missing discriminators - this shouldn't happen with native Anchor IDL
      console.warn('[DroogGameClient] IDL missing discriminators, attempting normalization...')
      
      // Need to add discriminators. Use deepCloneIdl which preserves structure
      const cloned = deepCloneIdl(DroogGameIDL)
      // Ensure the IDL address matches the actual program ID
      cloned.address = PROGRAM_ID.toString()
      normalizedIdlPromise = normalizeIdl(cloned)
    }
  }
  return normalizedIdlPromise
}

export class DroogGameClient {
  private program: AnyProgram
  private connection: Connection
  private provider: AnchorProvider

  /**
   * Private constructor - use DroogGameClient.create() instead.
   */
  private constructor(connection: Connection, wallet: Wallet, normalizedIdl: any) {
    // Validate wallet structure before creating provider
    if (!wallet.publicKey) {
      throw new Error('Wallet must have publicKey property')
    }
    if (!(wallet.publicKey instanceof PublicKey)) {
      throw new Error(`Wallet publicKey must be a PublicKey instance, got ${typeof wallet.publicKey}`)
    }
    if (typeof wallet.signTransaction !== 'function') {
      throw new Error('Wallet must have signTransaction method')
    }
    if (typeof wallet.signAllTransactions !== 'function') {
      throw new Error('Wallet must have signAllTransactions method')
    }

    this.connection = connection
    this.provider = new AnchorProvider(connection, wallet, {
      commitment: 'confirmed',
    })
    
    // Validate normalized IDL has Buffer discriminators
    if (normalizedIdl.instructions?.[0]?.discriminator) {
      const firstDiscriminator = normalizedIdl.instructions[0].discriminator
      if (!Buffer.isBuffer(firstDiscriminator)) {
        throw new Error(
          `IDL discriminator is not a Buffer. Got type: ${typeof firstDiscriminator}. ` +
          'IDL normalization failed. This is a bug.'
        )
      }
    }
    
    // Log MatchState account structure to see how array types are represented
    const matchStateAccount = normalizedIdl.accounts?.find((acc: any) => acc.name === 'MatchState')
    if (matchStateAccount) {
      const customersField = matchStateAccount.type?.fields?.find((f: any) => f.name === 'customers')
      if (customersField) {
        // Field type info available if needed for debugging
      }
    }
    
    // Log CustomerState type structure to debug option type issue
    const customerStateType = normalizedIdl.types?.find((t: any) => t.name === 'CustomerState')
    if (customerStateType) {
      const lastServedByField = customerStateType.type?.fields?.find((f: any) => f.name === 'lastServedBy')
      if (lastServedByField) {
        // Field type info available if needed for debugging
      }
    }
    
    // Use the normalized IDL directly
    // The normalizeIdl function already handles option types correctly
    // and adds Buffer discriminators, so we don't need the JSON round-trip
    try {
      // Try creating Program with the IDL as-is first
      // Anchor should be able to handle IDLs without discriminators (it computes them)
      // But if normalization added discriminators, use those
      
      // Create a clean copy to avoid mutating the original
      // Use deepCloneIdl to preserve Buffer discriminators (JSON.parse/stringify breaks Buffers)
      const idlForProgram = deepCloneIdl(normalizedIdl)
      
      // Temporarily remove events to avoid initialization errors
      // Events are not needed for basic program functionality and can be parsed from logs
      const originalEvents = idlForProgram.events
      delete idlForProgram.events
      
      // Ensure the IDL address matches the actual program ID
      // This is critical to avoid DeclaredProgramIdMismatch errors
      if (idlForProgram.address !== PROGRAM_ID.toString()) {
        console.warn('[DroogGameClient] IDL address mismatch, updating:', {
          idlAddress: idlForProgram.address,
          expectedAddress: PROGRAM_ID.toString(),
        })
        idlForProgram.address = PROGRAM_ID.toString()
      }
      
      // Debug: Log the IDL structure before creating Program
      console.log('[DroogGameClient] Creating Program with IDL:', {
        idlAddress: idlForProgram.address,
        programId: PROGRAM_ID.toString(),
        instructions: idlForProgram.instructions?.length,
        accounts: idlForProgram.accounts?.length,
        types: idlForProgram.types?.length,
        firstInstruction: idlForProgram.instructions?.[0] ? {
          name: idlForProgram.instructions[0].name,
          hasDiscriminator: !!idlForProgram.instructions[0].discriminator,
        } : null,
      })
      
      // Create Program - Anchor 0.30+ uses the IDL's address field as the program ID
      // We've ensured the address matches PROGRAM_ID above
      // Double-check the IDL address before creating Program
      if (idlForProgram.address !== PROGRAM_ID.toString()) {
        console.error('[DroogGameClient] CRITICAL: IDL address mismatch before Program creation:', {
          idlAddress: idlForProgram.address,
          expectedAddress: PROGRAM_ID.toString(),
        })
        idlForProgram.address = PROGRAM_ID.toString()
      }
      
      this.program = new Program(idlForProgram as any, this.provider)
      
      // Restore events after successful initialization
      // Anchor will still be able to parse events from transaction logs
      if (originalEvents && this.program.idl) {
        this.program.idl.events = originalEvents
      }
      
      // Verify program ID matches
      if (this.program.programId.toString() !== PROGRAM_ID.toString()) {
        console.error('[DroogGameClient] CRITICAL: Program ID mismatch after creation:', {
          programId: this.program.programId.toString(),
          expectedProgramId: PROGRAM_ID.toString(),
          idlAddress: this.program.idl?.address,
        })
        throw new Error(
          `Program ID mismatch: Program has ${this.program.programId.toString()}, expected ${PROGRAM_ID.toString()}. ` +
          `IDL address: ${this.program.idl?.address}. ` +
          `This indicates a DeclaredProgramIdMismatch will occur. ` +
          `Please ensure the program's declare_id! matches the deployed program ID.`
        )
      }
    } catch (error) {
      console.error('[DroogGameClient] Error creating Program:', error)
      console.error('[DroogGameClient] IDL type:', typeof normalizedIdl)
      console.error('[DroogGameClient] Provider wallet:', {
        publicKey: this.provider.wallet.publicKey?.toString(),
        hasSignTransaction: typeof this.provider.wallet.signTransaction === 'function',
      })
      // Log IDL structure for debugging
      console.error('[DroogGameClient] IDL accounts:', normalizedIdl.accounts?.map((acc: any) => acc.name))
      console.error('[DroogGameClient] IDL types:', normalizedIdl.types?.map((t: any) => t.name))
      if (normalizedIdl.instructions?.[0]?.accounts) {
        console.error('[DroogGameClient] First instruction accounts:', normalizedIdl.instructions[0].accounts.map((acc: any) => ({
          name: acc.name,
          type: acc.type,
        })))
      }
      // Log discriminator info for debugging
      if (normalizedIdl.instructions?.[0]) {
        console.error('[DroogGameClient] First instruction discriminator:', {
          name: normalizedIdl.instructions[0].name,
          type: typeof normalizedIdl.instructions[0].discriminator,
          isBuffer: Buffer.isBuffer(normalizedIdl.instructions[0].discriminator),
          value: normalizedIdl.instructions[0].discriminator,
        })
      }
      throw error
    }
  }

  /**
   * Fetch IDL from the chain for the deployed program.
   * This is useful when the local IDL might be out of sync.
   * 
   * @param connection - Solana connection
   * @param programId - Program public key
   * @returns Promise resolving to IDL or null if not found
   */
  static async fetchIdlFromChain(connection: Connection, programId: PublicKey): Promise<Idl | null> {
    try {
      // Note: Anchor's IDL derivation can vary by version
      // The IDL was deployed to: HTSsZsh85GJVoqACDqeAnpwHq2CCnSGuxdXgP81xwmJ6
      // Try the known deployed address first
      const knownIdlAddress = new PublicKey('HTSsZsh85GJVoqACDqeAnpwHq2CCnSGuxdXgP81xwmJ6')
      let accountInfo = await connection.getAccountInfo(knownIdlAddress)
      
      if (accountInfo) {
        // Anchor stores IDL in a binary format, not raw JSON
        // Use Anchor's IDL decoder to properly deserialize it
        try {
          // Anchor's IDL account structure:
          // - 8 bytes: account discriminator
          // - Remaining: compressed/encoded IDL data
          const idlData = accountInfo.data.slice(8)
          
          // Try to decode using Anchor's IDL decoder
          // The IDL is stored in a specific binary format that needs proper deserialization
          // For now, we'll skip the on-chain IDL fetch since it requires Anchor's internal decoders
          // The static IDL from target/idl/droog_game.json is the source of truth anyway
          return null
        } catch (parseError) {
          console.warn('[DroogGameClient] Failed to decode IDL data:', parseError)
        }
      }
      
      // Fallback: Try standard Anchor derivation (may not work for all Anchor versions)
      const [idlAddress] = PublicKey.findProgramAddressSync(
        [Buffer.from('anchor'), Buffer.from('idl'), programId.toBuffer()],
        programId
      )
      
      accountInfo = await connection.getAccountInfo(idlAddress)
      if (accountInfo) {
        // Same issue - IDL is in binary format, not JSON
        return null
      }
      
      // IDL not found - this is OK, we'll use the static IDL
      return null
    } catch (error) {
      console.warn('[DroogGameClient] Failed to fetch IDL from chain:', error)
      return null
    }
  }

  /**
   * Static factory method to create a DroogGameClient.
   * This normalizes the IDL (adds discriminators) before creating the Program.
   * If the static IDL fails, it will attempt to fetch the IDL from the chain.
   * 
   * @param connection - Solana connection
   * @param wallet - Anchor-compatible wallet
   * @returns Promise resolving to DroogGameClient instance
   */
  static async create(connection: Connection, wallet: Wallet): Promise<DroogGameClient> {
    // CRITICAL: Always try to fetch IDL from chain first to ensure we have the latest version
    // This is especially important after program upgrades
    const chainIdl = await this.fetchIdlFromChain(connection, PROGRAM_ID)
    
    let normalizedIdl: any
    if (chainIdl) {
      // Use on-chain IDL (most up-to-date)
      const cloned = deepCloneIdl(chainIdl)
      cloned.address = PROGRAM_ID.toString()
      normalizedIdl = await normalizeIdl(cloned)
      
      // Verify player_b is not a signer in the on-chain IDL
      const initMatchIx = normalizedIdl.instructions?.find((ix: any) => ix.name === 'initMatch')
      if (initMatchIx) {
        const playerBAccount = initMatchIx.accounts?.find((acc: any) => acc.name === 'playerB' || acc.name === 'player_b')
        if (playerBAccount) {
          if (playerBAccount.signer === true) {
            console.error('[DroogGameClient] ⚠️ WARNING: On-chain IDL shows player_b as signer! This indicates the deployed program is incorrect.')
          }
        }
      }
    } else {
      // Fallback to static IDL if chain fetch fails
      console.warn('[DroogGameClient] Failed to fetch IDL from chain, using static IDL...')
      normalizedIdl = await getNormalizedIdl()
    }
    
    // Try to create the client
    try {
      return new DroogGameClient(connection, wallet, normalizedIdl)
    } catch (error: any) {
      // If we get an InstructionFallbackNotFound error, try with static IDL
      const errorMessage = error?.message || error?.toString() || ''
      if (errorMessage.includes('InstructionFallbackNotFound') || errorMessage.includes('101')) {
        console.warn('[DroogGameClient] Chain IDL failed, trying static IDL...')
        normalizedIdl = await getNormalizedIdl()
        return new DroogGameClient(connection, wallet, normalizedIdl)
      }
      // Re-throw if it's a different error
      throw error
    }
  }

  /**
   * Derive Match PDA using hash-based seeds with player pubkeys.
   * This is the new deterministic approach that prevents collisions.
   * 
   * @param matchIdHash - 32-byte SHA-256 hash of the matchId string (must be Buffer)
   * @param playerA - First player's public key (will be sorted deterministically)
   * @param playerB - Second player's public key (will be sorted deterministically)
   * @returns [PDA public key, bump seed]
   */
  static deriveMatchPDAFromHash(
    matchIdHash: Buffer,
    playerA: PublicKey,
    playerB: PublicKey
  ): [PublicKey, number] {
    // Verify hash is a Buffer
    assertBuffer(matchIdHash, 'matchIdHash')
    
    // Sort pubkeys deterministically for consistent PDA derivation
    // Use the same sorting function as initMatch to ensure consistency
    const [first, second] = sortPlayerPubkeys(playerA, playerB)
    
    // Ensure all seeds are Buffers
    const firstBuffer = first.toBuffer()
    const secondBuffer = second.toBuffer()
    assertBuffer(firstBuffer, 'first player pubkey buffer')
    assertBuffer(secondBuffer, 'second player pubkey buffer')
    
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from('match'),
        matchIdHash,
        firstBuffer,
        secondBuffer
      ],
      PROGRAM_ID
    )
  }

  /**
   * Derive Match PDA (legacy method for backward compatibility).
   * @deprecated Use deriveMatchPDAFromHash() for new matches.
   */
  static deriveMatchPDA(matchId: number | BN): [PublicKey, number] {
    const matchIdBN = typeof matchId === 'number' ? new BN(matchId) : matchId
    return PublicKey.findProgramAddressSync(
      [Buffer.from('match'), matchIdBN.toArrayLike(Buffer, 'le', 8)],
      PROGRAM_ID
    )
  }

  /**
   * Derive Grow State PDA
   * Seeds: ["grow", match_id.to_le_bytes()]
   */
  static deriveGrowStatePDA(matchId: number | BN | bigint): [PublicKey, number] {
    const matchIdLE = u64ToLE(matchId)
    assertBuffer(matchIdLE, 'matchIdLE for grow PDA')
    return PublicKey.findProgramAddressSync(
      [Buffer.from('grow'), matchIdLE],
      PROGRAM_ID
    )
  }

  /**
   * Derive Delivery State PDA
   * Seeds: ["delivery", match_id.to_le_bytes()]
   */
  static deriveDeliveryStatePDA(matchId: number | BN | bigint): [PublicKey, number] {
    const matchIdLE = u64ToLE(matchId)
    assertBuffer(matchIdLE, 'matchIdLE for delivery PDA')
    return PublicKey.findProgramAddressSync(
      [Buffer.from('delivery'), matchIdLE],
      PROGRAM_ID
    )
  }

  /**
   * Helper method to sign and send a transaction with Privy embedded wallets.
   * 
   * For Anchor transactions with PDAs, we use sign-then-send with skipPreflight=true
   * because Privy's signAndSendTransaction simulates the transaction, which fails
   * for complex Anchor PDAs (accounts don't exist during simulation).
   */
  private async signAndSendWithPrivy(
    tx: Transaction,
    blockhash: string,
    lastValidBlockHeight: number,
    logPrefix: string = '[DroogGameClient]'
  ): Promise<string> {
    // For Anchor transactions, use sign-then-send to bypass simulation issues
    console.log(`${logPrefix} Using sign-then-send flow`)
    const signedTx = await this.provider.wallet.signTransaction(tx)
    
    // Verify signature is present
    const rawTx = signedTx.serialize()
    const sig = rawTx.slice(1, 65)
    const sigIsEmpty = sig.every((b: number) => b === 0)
    if (sigIsEmpty) {
      throw new Error('Transaction signature is empty - signing may have failed silently')
    }
    
    // Send the signed transaction
    const signature = await this.connection.sendRawTransaction(rawTx, {
      skipPreflight: true,
      preflightCommitment: 'confirmed',
    })
    
    console.log(`${logPrefix} Transaction sent:`, signature)
    
    // Wait for confirmation
    const confirmResult = await this.connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight,
    }, 'confirmed')
    
    if (confirmResult.value.err) {
      const txDetails = await this.connection.getTransaction(signature, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed',
      })
      console.error(`${logPrefix} Transaction logs:`, txDetails?.meta?.logMessages)
      throw new Error(`Transaction failed on-chain: ${JSON.stringify(confirmResult.value.err)}`)
    }
    
    console.log(`${logPrefix} Transaction confirmed:`, signature)
    return signature
  }

  /**
   * Initialize a new match on-chain using hash-based PDA seeds.
   * 
   * @param matchIdString - The string matchId (e.g., "match_1234567890_abc123")
   * @param startTs - Match start timestamp (Unix seconds)
   * @param playerA - First player's public key (must be < playerB for determinism)
   * @param playerB - Second player's public key (must be > playerA for determinism)
   * @returns Transaction signature
   */
  async initMatch(
    matchIdString: string,
    startTs: number,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    // Ensure deterministic ordering: playerA < playerB
    // Use the same sorting function as MatchStartModal to ensure consistency
    // This matches Rust's Pubkey comparison (lexicographic byte-by-byte)
    const [sortedA, sortedB] = sortPlayerPubkeys(playerA, playerB)
    
    // Validate the sorting is correct (sortedA must be < sortedB)
    const aBytes = sortedA.toBytes()
    const bBytes = sortedB.toBytes()
    for (let i = 0; i < aBytes.length; i++) {
      if (aBytes[i] > bBytes[i]) {
        throw new Error(
          `Invalid player order: sortedA (${sortedA.toString()}) > sortedB (${sortedB.toString()}) at byte ${i}. ` +
          `This indicates a bug in sortPlayerPubkeys.`
        )
      }
      if (aBytes[i] < bBytes[i]) {
        break // Order is correct
      }
    }

    // Create canonical match identity (normalizes all representations)
    const matchIdentity = await createMatchIdentity(matchIdString)
    
    // Verify all buffers are correct
    assertBuffer(matchIdentity.hash32, 'matchIdentity.hash32')
    assertBuffer(matchIdentity.u64le, 'matchIdentity.u64le')

    // Derive PDA using hash-based seeds (we'll verify this matches Anchor's derivation)
    let [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      sortedA,
      sortedB
    )

    // Derive staking-related PDAs
    const [stakePDA] = DroogGameClient.deriveStakePDA(matchIdentity.hash32)
    const [escrowPDA] = DroogGameClient.deriveEscrowPDA(matchIdentity.hash32)
    const [escrowAuthPDA] = DroogGameClient.deriveEscrowAuthorityPDA(matchIdentity.hash32)
    
    // Get player A's token account for $PACKS
    const playerATokenAccount = await getAssociatedTokenAddress(
      PACKS_MINT,
      sortedA,
      false,
      TOKEN_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID
    )

    // Convert hash to array for Anchor instruction (Anchor expects array, not Buffer)
    const matchIdHashArray = Array.from(matchIdentity.hash32)
    
    // Convert u64 bigint to BN for Anchor
    // For Option<u64>, pass the BN directly (Anchor handles Some/None wrapping)
    const matchIdU64BN = matchIdentity.u64

    // Verify the instruction exists in the IDL
    const idl = this.program.idl
    if (!idl || !idl.instructions) {
      throw new Error('Program IDL is missing or invalid')
    }
    
    const initMatchIx = idl.instructions.find((ix: any) => ix.name === 'initMatch')
    if (!initMatchIx) {
      console.error('[DroogGameClient.initMatch] Available instructions:', idl.instructions.map((ix: any) => ix.name))
      throw new Error(
        'initMatch instruction not found in program IDL. ' +
        'Available instructions: ' + idl.instructions.map((ix: any) => ix.name).join(', ')
      )
    }

    // Verify discriminator is a Buffer (required by Anchor)
    if (!initMatchIx.discriminator || !Buffer.isBuffer(initMatchIx.discriminator)) {
      console.warn('[DroogGameClient.initMatch] Missing or invalid discriminator, computing...')
      // Compute discriminator if missing
      const encoder = new TextEncoder()
      const data = encoder.encode(`global:${initMatchIx.name}`)
      const hashBuffer = await crypto.subtle.digest('SHA-256', data)
      const hash = Buffer.from(hashBuffer)
      initMatchIx.discriminator = hash.subarray(0, 8)
    }

    // Use type assertion to avoid TypeScript deep instantiation error
    const methods = this.program.methods as any
    
    // Also check for snake_case version
    const ixDefSnake = this.program.idl?.instructions?.find((ix: any) => ix.name === 'init_match')
    if (ixDefSnake) {
      console.warn('[DroogGameClient.initMatch] Found init_match (snake_case) but looking for initMatch (camelCase)')
    }
    
    // Debug: Check if method exists
    if (!methods.initMatch) {
      console.error('[DroogGameClient.initMatch] Method initMatch not found in program.methods')
      console.error('[DroogGameClient.initMatch] Program object keys:', Object.keys(this.program))
      console.error('[DroogGameClient.initMatch] Program.methods type:', typeof methods)
      
      // Try to manually construct using the coder
      console.warn('[DroogGameClient.initMatch] Attempting manual instruction construction...')
      try {
        const discriminator = initMatchIx.discriminator
        if (!discriminator || !Buffer.isBuffer(discriminator)) {
          throw new Error('Discriminator is missing or invalid')
        }
        
        // Encode the instruction data manually
        const coder = this.program.coder
        // For Option<u64>, Anchor expects { some: value } or null
        // But when encoding, we can pass the value directly and Anchor handles it
        const args = {
          matchIdHash: matchIdHashArray,
          matchId: matchIdU64BN, // Option<u64> - Anchor will wrap this as Some(value)
          startTs: new BN(startTs),
        }
        
        // Encode instruction data using the instruction name
        // The coder will use the discriminator from the IDL
        const data = coder.instruction.encode(initMatchIx.name, args)
        
        // Create instruction
        // Note: player_b (sortedB) is NOT a signer - only player_a (sortedA) signs
        // The Rust program uses UncheckedAccount for player_b
        const instruction = new TransactionInstruction({
          programId: this.program.programId,
          keys: [
            { pubkey: matchPDA, isSigner: false, isWritable: true },
            { pubkey: sortedA, isSigner: true, isWritable: true },
            { pubkey: sortedB, isSigner: false, isWritable: false }, // Not a signer
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
          ],
          data,
        })
        
        // Create transaction and prepare it for signing
        const tx = new Transaction().add(instruction)
        
        // Get recent blockhash
        const { blockhash: manualBlockhash, lastValidBlockHeight: manualLastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed')
        tx.recentBlockhash = manualBlockhash
        tx.feePayer = this.provider.wallet.publicKey
        
        // Use helper to sign and send with Privy priority
        return await this.signAndSendWithPrivy(tx, manualBlockhash, manualLastValidBlockHeight, '[DroogGameClient.initMatch.manual]')
      } catch (manualError) {
        console.error('[DroogGameClient.initMatch] Manual construction failed:', manualError)
        throw new Error('initMatch method not found and manual construction failed: ' + (manualError as Error).message)
      }
    }
    
    try {
      // CRITICAL: Try to get Anchor to derive the PDA by building the instruction
      // without passing matchState, then extract what PDA it derived
      let anchorDerivedPDA: PublicKey | null = null
      
      try {
        // Build instruction without matchState to see what Anchor derives
        const testInstruction = await methods
          .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
          .accounts({
            // Staking accounts
            stakeState: stakePDA,
            mint: PACKS_MINT,
            playerATokenAccount: playerATokenAccount,
            escrowTokenAccount: escrowPDA,
            escrowAuthority: escrowAuthPDA,
            // Player accounts
            playerA: sortedA,
            playerB: sortedB,
            // Programs
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .instruction()
        
        // Extract the PDA from the instruction's account keys
        // The first account should be the matchState PDA
        if (testInstruction.keys && testInstruction.keys.length > 0) {
          const extractedPDA = testInstruction.keys[0].pubkey
          anchorDerivedPDA = extractedPDA
        }
      } catch (e) {
        console.warn('[DroogGameClient.initMatch] Could not extract PDA from instruction:', e)
      }
      
      // Also manually verify our derivation
      const manualSeeds = [
        Buffer.from('match'),
        matchIdentity.hash32,
        sortedA.toBuffer(),
        sortedB.toBuffer()
      ]
      const [manualPDA, manualBump] = PublicKey.findProgramAddressSync(
        manualSeeds,
        PROGRAM_ID
      )
      
      // Use Anchor's derived PDA if we got it, otherwise use our manual derivation
      const finalPDA = anchorDerivedPDA ?? matchPDA
      
      // Update matchPDA to use the final PDA
      if (!matchPDA.equals(finalPDA)) {
        console.warn('[DroogGameClient.initMatch] Using different PDA than our initial derivation')
        matchPDA = finalPDA
      }
      
      // Let Anchor derive the PDA automatically using the instruction args
      // The IDL specifies that match_id_hash comes from instruction args, so Anchor should derive it correctly
      
      // Verify program ID before executing instruction
      if (this.program.programId.toString() !== PROGRAM_ID.toString()) {
        throw new Error(
          `Program ID mismatch before instruction execution. ` +
          `Program has ${this.program.programId.toString()}, expected ${PROGRAM_ID.toString()}. ` +
          `This will cause DeclaredProgramIdMismatch. Please rebuild and redeploy the program.`
        )
      }
      
      try {
        // Validate account order before passing to Anchor
        // The Rust constraint requires player_a.key() < player_b.key()
        // Anchor maps camelCase (playerA) to snake_case (player_a)
        const aBytes = sortedA.toBytes()
        const bBytes = sortedB.toBytes()
        let isValidOrder = false
        for (let i = 0; i < aBytes.length; i++) {
          if (aBytes[i] < bBytes[i]) {
            isValidOrder = true
            break
          }
          if (aBytes[i] > bBytes[i]) {
            throw new Error(
              `CRITICAL: Account order validation failed! ` +
              `sortedA (${sortedA.toString()}) > sortedB (${sortedB.toString()}) at byte ${i}. ` +
              `This will cause InvalidPlayerOrder error.`
            )
          }
        }
        
        if (!isValidOrder) {
          // This should never happen if the validation in MatchStartModal works correctly
          // But if it does, we need to fail fast and not attempt the transaction
          const error = new Error(
            `CRITICAL: Cannot create match - both players have the same wallet address! ` +
            `Both players: ${sortedA.toString()}. ` +
            `This is a configuration error - check that playerAWallet and playerBWallet are different.`
          )
          console.error('[DroogGameClient.initMatch]', error.message)
          throw error
        }
        
        // CRITICAL: Build instruction manually to ensure player_b is NOT a signer
        // Anchor's .rpc() might incorrectly infer player_b as a signer, so we build
        // the instruction explicitly and then send it with correct account metadata
        
        // Build the instruction using Anchor's builder
        const instruction = await methods
          .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
          .accounts({
            // Match state PDA (CRITICAL - must be first in order)
            matchState: matchPDA,
            // Staking accounts
            stakeState: stakePDA,
            mint: PACKS_MINT,
            playerATokenAccount: playerATokenAccount,
            escrowTokenAccount: escrowPDA,
            escrowAuthority: escrowAuthPDA,
            // Player accounts - IMPORTANT: playerA maps to player_a in Rust
            // The Rust constraint requires player_a.key() < player_b.key()
            playerA: sortedA,
            playerB: sortedB,
            // Programs
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          } as any)
          .instruction()
        
        // CRITICAL: Verify and fix account metadata to ensure player_b is NOT a signer
        // The IDL says player_b should NOT be a signer (UncheckedAccount in Rust)
        // Find player_b in the instruction keys and ensure isSigner is false
        let playerBIndex = -1
        for (let i = 0; i < instruction.keys.length; i++) {
          const key = instruction.keys[i]
          // player_b should be the third account (after matchState and playerA)
          // We'll identify it by checking if it matches sortedB
          if (key.pubkey.equals(sortedB)) {
            playerBIndex = i
            // CRITICAL FIX: Ensure player_b is NOT a signer
            if (key.isSigner) {
              console.warn('[DroogGameClient.initMatch] ⚠️ player_b was incorrectly marked as signer, fixing...')
              instruction.keys[i] = {
                ...key,
                isSigner: false,
              }
            }
            break
          }
        }
        
        if (playerBIndex === -1) {
          console.error('[DroogGameClient.initMatch] Could not find player_b in instruction keys')
          throw new Error('Failed to locate player_b account in instruction')
        }
        
        // CRITICAL: Double-check player_b is NOT a signer before sending
        if (instruction.keys[playerBIndex].isSigner) {
          console.error('[DroogGameClient.initMatch] ❌ CRITICAL: player_b is still marked as signer after fix!')
          throw new Error('player_b cannot be a signer - this indicates a bug in the fix')
        }
        
        // Create transaction and prepare it for signing
        const tx = new Transaction().add(instruction)
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed')
        tx.recentBlockhash = blockhash
        tx.feePayer = this.provider.wallet.publicKey
        
        // Find the player_a account (should be a signer)
        const playerAAccount = instruction.keys.find((k: any) => k.pubkey.equals(sortedA))
        const walletPubkey = this.provider.wallet.publicKey
        
        console.log('[DroogGameClient.initMatch] CRITICAL: Verifying signer match:', {
          walletPublicKey: walletPubkey.toString(),
          sortedA: sortedA.toString(),
          sortedB: sortedB.toString(),
          walletEqualsPlayerA: walletPubkey.equals(sortedA),
          walletEqualsPlayerB: walletPubkey.equals(sortedB),
          playerAIsSigner: playerAAccount?.isSigner,
        })
        
        // CRITICAL: Ensure wallet matches player_a (the signer)
        if (!walletPubkey.equals(sortedA)) {
          throw new Error(
            `CRITICAL: Wallet mismatch! ` +
            `Wallet (${walletPubkey.toString()}) does not match player_a (${sortedA.toString()}). ` +
            `Only the player with the lower pubkey can submit initMatch. ` +
            `The other player should wait and call joinMatchWithStake.`
          )
        }
        
        console.log('[DroogGameClient.initMatch] Transaction before signing:', {
          feePayer: tx.feePayer?.toString(),
          recentBlockhash: tx.recentBlockhash,
          signaturesCount: tx.signatures.length,
        })
        
        // Log each account with its expected role
        const accountRoles = [
          'matchState (PDA)',
          'stakeState (PDA)', 
          'mint',
          'playerATokenAccount',
          'escrowTokenAccount (PDA)',
          'escrowAuthority (PDA)',
          'playerA (SIGNER)',
          'playerB',
          'tokenProgram',
          'associatedTokenProgram',
          'systemProgram'
        ]
        console.log('[DroogGameClient.initMatch] Instruction accounts:')
        instruction.keys.forEach((k: any, idx: number) => {
          const role = accountRoles[idx] || `unknown_${idx}`
          const isPlayerA = k.pubkey.equals(sortedA)
          const isPlayerB = k.pubkey.equals(sortedB)
          console.log(`  [${idx}] ${role}: ${k.pubkey.toString().substring(0, 8)}... isSigner=${k.isSigner} isWritable=${k.isWritable} ${isPlayerA ? '(=sortedA)' : ''} ${isPlayerB ? '(=sortedB)' : ''}`)
        })
        
        // CRITICAL: Analyze the compiled transaction to see actual account ordering
        // When the transaction is compiled, accounts are reordered: signers first, then non-signers
        // The instruction indices are remapped to match this new order
        console.log('[DroogGameClient.initMatch] Analyzing compiled message structure:')
        const compiledMessage = tx.compileMessage()
        console.log('[DroogGameClient.initMatch] Message header:', {
          numRequiredSignatures: compiledMessage.header.numRequiredSignatures,
          numReadonlySignedAccounts: compiledMessage.header.numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: compiledMessage.header.numReadonlyUnsignedAccounts,
        })
        console.log('[DroogGameClient.initMatch] Account keys in message order:')
        compiledMessage.accountKeys.forEach((key, idx) => {
          const isPlayerA = key.equals(sortedA)
          const isPlayerB = key.equals(sortedB)
          const isSignerPosition = idx < compiledMessage.header.numRequiredSignatures
          console.log(`  [${idx}] ${key.toString().substring(0, 8)}... ${isSignerPosition ? '(SIGNER POSITION)' : ''} ${isPlayerA ? '(=sortedA/playerA)' : ''} ${isPlayerB ? '(=sortedB/playerB)' : ''}`)
        })
        
        // Find where player_a ended up in the compiled message
        const playerAIndex = compiledMessage.accountKeys.findIndex(key => key.equals(sortedA))
        const isPlayerAInSignerPosition = playerAIndex < compiledMessage.header.numRequiredSignatures
        console.log('[DroogGameClient.initMatch] CRITICAL: player_a index in message:', playerAIndex, 
          isPlayerAInSignerPosition ? '✓ IN SIGNER POSITION' : '❌ NOT IN SIGNER POSITION - THIS IS THE BUG!')
        
        // CRITICAL DEBUG: Check the compiled instruction's account indices
        // The instruction should reference accounts by their index in the message's accountKeys array
        console.log('[DroogGameClient.initMatch] Compiled instruction analysis:')
        compiledMessage.instructions.forEach((compiledIx, ixIdx) => {
          console.log(`  Instruction ${ixIdx}: programIdIndex=${compiledIx.programIdIndex}`)
          console.log(`  Account indices: [${compiledIx.accounts.join(', ')}]`)
          
          // Map the instruction's account indices back to pubkeys and check signer status
          console.log(`  Decoded accounts:`)
          compiledIx.accounts.forEach((acctIdx, i) => {
            const pubkey = compiledMessage.accountKeys[acctIdx]
            const isSignerInMessage = acctIdx < compiledMessage.header.numRequiredSignatures
            const isPlayerA = pubkey.equals(sortedA)
            const role = accountRoles[i] || `unknown_${i}`
            console.log(`    [${i}] ${role}: msgIdx=${acctIdx} -> ${pubkey.toString().substring(0, 8)}... ${isSignerInMessage ? '(SIGNER IN MSG)' : ''} ${isPlayerA ? '(=playerA)' : ''}`)
          })
        })
        
        // Serialize unsigned transaction for Privy to sign
        const unsignedTxBytes = tx.serialize({
          requireAllSignatures: false,
          verifySignatures: false,
        })
        
        console.log('[DroogGameClient.initMatch] Unsigned transaction bytes length:', unsignedTxBytes.length)
        
        // For Anchor transactions with PDAs, use sign-then-send as primary approach
        // Privy's signAndSendTransaction simulates the transaction, which fails for complex
        // Anchor PDAs because the accounts don't exist yet during simulation.
        // Sign-then-send with skipPreflight=true bypasses this issue.
        console.log('[DroogGameClient.initMatch] Using sign-then-send flow (recommended for Anchor PDAs)')
        const signedTx = await this.provider.wallet.signTransaction(tx)
        
        // Verify the signature is valid
        const signerPubkey = signedTx.signatures[0]?.publicKey
        const hasValidSignature = signedTx.signatures[0]?.signature && signedTx.signatures[0].signature.length === 64
        
        console.log('[DroogGameClient.initMatch] Transaction after signing:', {
          signaturesCount: signedTx.signatures.length,
          signerMatchesWallet: signerPubkey?.equals(this.provider.wallet.publicKey),
          signerMatchesPlayerA: signerPubkey?.equals(sortedA),
          hasValidSignature,
        })
        
        // CRITICAL: Verify the signer pubkey in the signed transaction matches player_a
        if (signerPubkey && !signerPubkey.equals(sortedA)) {
          console.error('[DroogGameClient.initMatch] ❌ CRITICAL: Signer pubkey mismatch!', {
            signerInTx: signerPubkey.toString(),
            expectedPlayerA: sortedA.toString(),
          })
          throw new Error(`Signer mismatch: expected ${sortedA.toString()}, got ${signerPubkey.toString()}`)
        }
        
        // Serialize the signed transaction
        const rawTx = signedTx.serialize()
        console.log('[DroogGameClient.initMatch] Raw transaction size:', rawTx.length, 'bytes')
        
        // Verify signature is present (not all zeros)
        const sig = rawTx.slice(1, 65)
        const sigIsEmpty = sig.every((b: number) => b === 0)
        if (sigIsEmpty) {
          console.error('[DroogGameClient.initMatch] ❌ CRITICAL: Signature is empty/zeros!')
          throw new Error('Transaction signature is empty - Privy signing may have failed silently')
        }
        
        // Debug: Parse the serialized transaction to verify account ordering
        // Format: [num_sigs (1 byte)] [sig0 (64 bytes)] ... [message]
        const numSigs = rawTx[0]
        const messageOffset = 1 + (numSigs * 64)
        const messageBytes = rawTx.slice(messageOffset)
        
        // Message format: [header (3 bytes)] [num_accounts (compact-u16)] [account keys (32 each)] ...
        const header = messageBytes.slice(0, 3)
        const numRequiredSigs = header[0]
        const numReadonlySigned = header[1]
        const numReadonlyUnsigned = header[2]
        
        console.log('[DroogGameClient.initMatch] Transaction structure:', {
          numSignatures: numSigs,
          messageOffset,
          messageLength: messageBytes.length,
          header: {
            numRequiredSignatures: numRequiredSigs,
            numReadonlySignedAccounts: numReadonlySigned,
            numReadonlyUnsignedAccounts: numReadonlyUnsigned,
          },
        })
        
        // CRITICAL DEBUG: Parse the raw instruction to verify account index for player_a
        // The instruction's account at position 6 (player_a in struct) should have index 0 (signer position)
        // Parse the compiled message to extract instruction account indices
        try {
          // Format after header: [num_account_keys (compact)] [account_keys...] [blockhash] [num_instructions (compact)] [instructions...]
          // For now, use the already-parsed compiledMessage
          const msgInstructions = compiledMessage.instructions
          if (msgInstructions.length > 0) {
            const ix = msgInstructions[0]
            console.log('[DroogGameClient.initMatch] CRITICAL - Raw instruction account indices:', ix.accounts)
            console.log('[DroogGameClient.initMatch] CRITICAL - player_a struct index is 6')
            console.log('[DroogGameClient.initMatch] CRITICAL - Instruction account[6] value:', ix.accounts[6])
            const isPlayerAIndexedCorrectly = ix.accounts[6] < numRequiredSigs
            console.log('[DroogGameClient.initMatch] CRITICAL - Is account[6] in signer position (<', numRequiredSigs, ')?', isPlayerAIndexedCorrectly)
            if (!isPlayerAIndexedCorrectly) {
              console.error('[DroogGameClient.initMatch] ❌❌❌ BUG FOUND: player_a (instruction index 6) maps to message index', ix.accounts[6], 'which is NOT a signer position!')
              console.error('[DroogGameClient.initMatch] Expected message index 0, got', ix.accounts[6])
            } else {
              console.log('[DroogGameClient.initMatch] ✓ player_a correctly indexed as signer')
            }
          }
        } catch (parseErr) {
          console.error('[DroogGameClient.initMatch] Error parsing instruction indices:', parseErr)
        }
        
        // The first account in the message should be the fee payer (player_a)
        // Account keys start after the header and compact-u16 num_accounts
        // For simplicity, we'll just verify the first signer in the Transaction object
        console.log('[DroogGameClient.initMatch] Fee payer in tx:', signedTx.feePayer?.toString())
        console.log('[DroogGameClient.initMatch] First signature pubkey:', signedTx.signatures[0]?.publicKey?.toString())
        console.log('[DroogGameClient.initMatch] Expected player_a:', sortedA.toString())
        
        // CRITICAL: Verify the fee payer matches player_a (the signer expected by the program)
        if (!signedTx.feePayer?.equals(sortedA)) {
          console.error('[DroogGameClient.initMatch] ❌ Fee payer does not match player_a!', {
            feePayer: signedTx.feePayer?.toString(),
            playerA: sortedA.toString(),
          })
        } else {
          console.log('[DroogGameClient.initMatch] ✓ Fee payer matches player_a')
        }
        
        console.log('[DroogGameClient.initMatch] ✓ Signature present, sending transaction...')
        
        // Debug: Manually verify the ed25519 signature before sending
        // The signature is over the message bytes
        try {
          const messageForSigning = signedTx.serializeMessage()
          const signatureBytes = signedTx.signatures[0].signature
          const signerPubkeyBytes = signedTx.signatures[0].publicKey?.toBytes()
          
          console.log('[DroogGameClient.initMatch] Signature verification details:', {
            messageLength: messageForSigning.length,
            signaturePresent: !!signatureBytes,
            signatureLength: signatureBytes?.length,
            signerPubkey: signedTx.signatures[0].publicKey?.toString(),
            signerMatchesSortedA: signedTx.signatures[0].publicKey?.equals(sortedA),
            // First 32 bytes of message (should contain header + first accounts)
            messagePreview: Buffer.from(messageForSigning.slice(0, 32)).toString('hex'),
          })
        } catch (verifyErr) {
          console.error('[DroogGameClient.initMatch] Error getting verification details:', verifyErr)
        }
        
        // Send the signed transaction
        const signature = await this.connection.sendRawTransaction(rawTx, {
          skipPreflight: true, // Skip simulation since it may fail with embedded wallets
          preflightCommitment: 'confirmed',
        })
        
        console.log('[DroogGameClient.initMatch] Transaction sent (manual):', signature)
        
        // Wait for confirmation with better error handling
        let confirmResult
        try {
          console.log('[DroogGameClient.initMatch] Waiting for confirmation...')
          confirmResult = await this.connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight,
          }, 'confirmed')
        } catch (confirmError: any) {
          console.error('[DroogGameClient.initMatch] Confirmation failed:', confirmError?.message)
          // Transaction might still have succeeded, try to fetch it
          try {
            const txDetails = await this.connection.getTransaction(signature, {
              maxSupportedTransactionVersion: 0,
              commitment: 'confirmed',
            })
            if (txDetails?.meta && !txDetails.meta.err) {
              console.log('[DroogGameClient.initMatch] Transaction actually succeeded despite confirmation timeout:', signature)
              return signature
            }
            console.error('[DroogGameClient.initMatch] Transaction status:', txDetails?.meta?.err || 'unknown')
          } catch (fetchError: any) {
            console.error('[DroogGameClient.initMatch] Could not fetch transaction status:', fetchError?.message)
          }
          throw confirmError
        }
        
        // CRITICAL: Check if the transaction actually succeeded
        if (confirmResult.value.err) {
          console.error('[DroogGameClient.initMatch] Transaction FAILED on-chain:', confirmResult.value.err)
          
          // Fetch transaction to get logs
          const txDetails = await this.connection.getTransaction(signature, {
            maxSupportedTransactionVersion: 0,
            commitment: 'confirmed',
          })
          console.error('[DroogGameClient.initMatch] Transaction logs:', txDetails?.meta?.logMessages)
          
          throw new Error(`Transaction failed on-chain: ${JSON.stringify(confirmResult.value.err)}`)
        }
        
        console.log('[DroogGameClient.initMatch] Transaction confirmed successfully:', signature)
        
        return signature
      } catch (error: any) {
        const errorMessage = error?.message || error?.toString() || 'Unknown error'
        console.error('[DroogGameClient.initMatch] Auto-derive failed:', errorMessage)
        console.error('[DroogGameClient.initMatch] Error details:', {
          message: errorMessage,
          logs: error?.logs,
          errorCode: error?.error?.errorCode,
          programId: this.program.programId.toString(),
          expectedProgramId: PROGRAM_ID.toString(),
        })
        // Log the full error object to see what Anchor is comparing
        if (error?.logs) {
          console.error('[DroogGameClient.initMatch] Transaction logs:', error.logs)
        }
        if (error?.error?.errorCode?.code === 'DeclaredProgramIdMismatch') {
          console.error('[DroogGameClient.initMatch] DeclaredProgramIdMismatch detected!')
          console.error('[DroogGameClient.initMatch] This means the deployed program binary has a different declare_id! than expected.')
          console.error('[DroogGameClient.initMatch] Client expects:', PROGRAM_ID.toString())
          console.error('[DroogGameClient.initMatch] Program instance has:', this.program.programId.toString())
          console.error('[DroogGameClient.initMatch] Solution: Rebuild and redeploy the program with: anchor build && anchor deploy')
        }
        
        // Don't try fallback if accounts are identical - this is a configuration error
        if (errorMessage.includes('identical pubkeys') || errorMessage.includes('same wallet address')) {
          console.error('[DroogGameClient.initMatch] Skipping fallback - accounts are identical. This is a configuration error.')
          throw error
        }
        
        // Fallback: Try with explicit PDA
        // Re-validate order for fallback (should already be validated, but double-check)
        const fallbackABytes = sortedA.toBytes()
        const fallbackBBytes = sortedB.toBytes()
        for (let i = 0; i < fallbackABytes.length; i++) {
          if (fallbackABytes[i] > fallbackBBytes[i]) {
            throw new Error(
              `CRITICAL: Account order validation failed in fallback! ` +
              `sortedA (${sortedA.toString()}) > sortedB (${sortedB.toString()}) at byte ${i}.`
            )
          }
          if (fallbackABytes[i] < fallbackBBytes[i]) {
            break // Order is correct
          }
        }
        
        try {
          // Build instruction manually to ensure player_b is NOT a signer
          const instruction = await methods
            .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
            .accounts({
              matchState: matchPDA, // Explicit PDA
              stakeState: stakePDA,
              mint: PACKS_MINT,
              playerATokenAccount: playerATokenAccount,
              escrowTokenAccount: escrowPDA,
              escrowAuthority: escrowAuthPDA,
              // IMPORTANT: Ensure same order as above - playerA < playerB
              playerA: sortedA,
              playerB: sortedB,
              tokenProgram: TOKEN_PROGRAM_ID,
              associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
              systemProgram: SystemProgram.programId,
            } as any)
            .instruction()
          
          // CRITICAL: Verify and fix account metadata to ensure player_b is NOT a signer
          for (let i = 0; i < instruction.keys.length; i++) {
            const key = instruction.keys[i]
            if (key.pubkey.equals(sortedB)) {
              if (key.isSigner) {
                console.warn('[DroogGameClient.initMatch] ⚠️ Fallback: player_b was incorrectly marked as signer, fixing...')
                instruction.keys[i] = {
                  ...key,
                  isSigner: false,
                }
              }
              break
            }
          }
          
          // Create transaction and prepare it for signing
          const tx = new Transaction().add(instruction)
          
          // Get recent blockhash
          const { blockhash: fallbackBlockhash, lastValidBlockHeight: fallbackLastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed')
          tx.recentBlockhash = fallbackBlockhash
          tx.feePayer = this.provider.wallet.publicKey
          
          // Use helper to sign and send with Privy priority
          return await this.signAndSendWithPrivy(tx, fallbackBlockhash, fallbackLastValidBlockHeight, '[DroogGameClient.initMatch.fallback]')
        } catch (fallbackError: any) {
          console.error('[DroogGameClient.initMatch] All approaches failed. Last error:', fallbackError.message)
          console.error('[DroogGameClient.initMatch] Final error details:', {
            message: fallbackError.message,
            logs: fallbackError.logs,
            errorCode: fallbackError.error?.errorCode,
            programId: this.program.programId.toString(),
            expectedProgramId: PROGRAM_ID.toString(),
          })
          if (fallbackError.logs) {
            console.error('[DroogGameClient.initMatch] Final transaction logs:', fallbackError.logs)
          }
          if (fallbackError.error?.errorCode?.code === 'DeclaredProgramIdMismatch') {
            console.error('[DroogGameClient.initMatch] ⚠️ CRITICAL: DeclaredProgramIdMismatch error')
            console.error('[DroogGameClient.initMatch] The deployed program binary was compiled with a different declare_id!')
            console.error('[DroogGameClient.initMatch] Expected program ID:', PROGRAM_ID.toString())
            console.error('[DroogGameClient.initMatch] Program instance ID:', this.program.programId.toString())
            console.error('[DroogGameClient.initMatch]')
            console.error('[DroogGameClient.initMatch] To fix this:')
            console.error('[DroogGameClient.initMatch] 1. Ensure programs/droog-game/src/lib.rs has: declare_id!("' + PROGRAM_ID.toString() + '")')
            console.error('[DroogGameClient.initMatch] 2. Run: anchor keys sync')
            console.error('[DroogGameClient.initMatch] 3. Run: anchor build')
            console.error('[DroogGameClient.initMatch] 4. Run: anchor deploy --provider.cluster devnet')
          }
          throw fallbackError
        }
      }
    } catch (error: any) {
      // If we get InstructionFallbackNotFound, the IDL might be out of sync
      const errorMessage = error?.message || error?.toString() || ''
      if (errorMessage.includes('InstructionFallbackNotFound') || errorMessage.includes('101')) {
        console.error('[DroogGameClient.initMatch] InstructionFallbackNotFound error - IDL may be out of sync')
        console.error('[DroogGameClient.initMatch] Program ID:', this.program.programId.toString())
        console.error('[DroogGameClient.initMatch] IDL instructions:', idl.instructions.map((ix: any) => ({
          name: ix.name,
          discriminator: ix.discriminator ? Array.from(ix.discriminator) : 'missing',
        })))
        
        // Try to fetch IDL from chain and recreate the client
        console.warn('[DroogGameClient.initMatch] Attempting to fetch IDL from chain...')
        try {
          const chainIdl = await DroogGameClient.fetchIdlFromChain(this.connection, this.program.programId)
          if (chainIdl) {
            // Normalize the fetched IDL
            const cloned = deepCloneIdl(chainIdl)
            // Ensure the IDL address matches the actual program ID
            cloned.address = PROGRAM_ID.toString()
            const normalizedIdl = await normalizeIdl(cloned)
            
            // Recreate the program with the fetched IDL
            const idlWithoutEvents = { ...normalizedIdl }
            // Ensure address is set (normalizeIdl might not preserve it)
            idlWithoutEvents.address = PROGRAM_ID.toString()
            const originalEvents = idlWithoutEvents.events
            delete idlWithoutEvents.events
            
            this.program = new Program(idlWithoutEvents as any, this.provider)
            
            if (originalEvents && this.program.idl) {
              this.program.idl.events = originalEvents
            }
            
            // Retry the call with the new program
            const retryMethods = this.program.methods as any
            const tx = await retryMethods
              .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
              .accounts({
                matchState: matchPDA,
                stakeState: stakePDA,
                mint: PACKS_MINT,
                playerATokenAccount: playerATokenAccount,
                escrowTokenAccount: escrowPDA,
                escrowAuthority: escrowAuthPDA,
                playerA: sortedA,
                playerB: sortedB,
                tokenProgram: TOKEN_PROGRAM_ID,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
              })
              .rpc()
            
            return tx
          }
        } catch (fetchError) {
          console.error('[DroogGameClient.initMatch] Failed to fetch IDL from chain:', fetchError)
        }
        
        throw new Error(
          'InstructionFallbackNotFound: The program IDL may be out of sync with the deployed program. ' +
          'Please rebuild and redeploy the program, or ensure the IDL is up to date.'
        )
      }
      throw error
    }
  }

  // ==========================================================================
  // STAKING METHODS (Option C)
  // ==========================================================================

  /**
   * Derive stake state PDA from match ID hash.
   * Seeds: ["stake", match_id_hash]
   */
  static deriveStakePDA(matchIdHash: Buffer): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('stake'), matchIdHash],
      PROGRAM_ID
    )
  }

  /**
   * Derive escrow token account PDA.
   * Seeds: ["escrow", match_id_hash]
   */
  static deriveEscrowPDA(matchIdHash: Buffer): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('escrow'), matchIdHash],
      PROGRAM_ID
    )
  }

  /**
   * Derive escrow authority PDA.
   * Seeds: ["escrow_auth", match_id_hash]
   */
  static deriveEscrowAuthorityPDA(matchIdHash: Buffer): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('escrow_auth'), matchIdHash],
      PROGRAM_ID
    )
  }

  /**
   * Get or create the player's Associated Token Account for $PACKS.
   */
  async getOrCreatePlayerTokenAccount(
    player: PublicKey,
    payer?: PublicKey
  ): Promise<PublicKey> {
    const ata = await getAssociatedTokenAddress(
      PACKS_MINT,
      player,
      false,
      TOKEN_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID
    )
    
    try {
      await getAccount(this.connection, ata)
      return ata
    } catch {
      // ATA doesn't exist, create it
      const createAtaIx = createAssociatedTokenAccountInstruction(
        payer ?? player,
        ata,
        player,
        PACKS_MINT,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_TOKEN_PROGRAM_ID
      )
      
      // Create transaction and prepare it for signing
      const tx = new Transaction().add(createAtaIx)
      
      // Get recent blockhash
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed')
      tx.recentBlockhash = blockhash
      tx.feePayer = this.provider.wallet.publicKey
      
      // Use helper to sign and send with Privy priority
      await this.signAndSendWithPrivy(tx, blockhash, lastValidBlockHeight, '[DroogGameClient.getOrCreatePlayerTokenAccount]')
      
      return ata
    }
  }

  /**
   * Get stake state for a match.
   */
  async getStakeState(matchIdString: string): Promise<StakeState | null> {
    try {
      await rpcThrottle.acquire()
      
      const matchIdentity = await createMatchIdentity(matchIdString)
      const [stakePDA] = DroogGameClient.deriveStakePDA(matchIdentity.hash32)
      
      const account = await (this.program.account as any).matchStakeState.fetch(stakePDA)
      
      // Convert status from enum object to string
      let status: MatchStatus = 'pending'
      if (account.status.active !== undefined) status = 'active'
      else if (account.status.finalized !== undefined) status = 'finalized'
      else if (account.status.cancelled !== undefined) status = 'cancelled'
      
      return {
        matchId: account.matchId,
        matchIdHash: Array.from(account.matchIdHash),
        playerA: account.playerA,
        playerB: account.playerB,
        status,
        playerAEscrowed: account.playerAEscrowed,
        playerBEscrowed: account.playerBEscrowed,
        createdAt: account.createdAt,
        bump: account.bump,
        escrowBump: account.escrowBump,
      }
    } catch {
      return null
    }
  }

  /**
   * Player B joins the match and stakes their tokens.
   * 
   * Option C Critical:
   * - Player B escrows 100% of stake
   * - Burn occurs here (10% of total)
   * - Match becomes Active atomically with burn
   */
  async joinMatchWithStake(matchIdString: string): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const matchIdHashArray = Array.from(matchIdentity.hash32)
    
    // Derive PDAs
    const [stakePDA] = DroogGameClient.deriveStakePDA(matchIdentity.hash32)
    const [escrowPDA] = DroogGameClient.deriveEscrowPDA(matchIdentity.hash32)
    const [escrowAuthPDA] = DroogGameClient.deriveEscrowAuthorityPDA(matchIdentity.hash32)
    
    // Get player B's wallet (current signer)
    const playerB = this.provider.wallet.publicKey
    
    // Get or create player B's token account
    const playerBTokenAccount = await this.getOrCreatePlayerTokenAccount(playerB)
    
    const methods = this.program.methods as any
    
    const instruction = await methods
      .joinMatchWithStake()
      .accounts({
        stakeState: stakePDA,
        mint: PACKS_MINT,
        playerBTokenAccount: playerBTokenAccount,
        escrowTokenAccount: escrowPDA,
        escrowAuthority: escrowAuthPDA,
        playerB: playerB,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      } as any)
      .instruction()
    
    // Create transaction and prepare it for signing
    const tx = new Transaction().add(instruction)
    
    // Get recent blockhash
    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed')
    tx.recentBlockhash = blockhash
    tx.feePayer = this.provider.wallet.publicKey
    
    // Use sign-then-send flow (Privy's signAndSendTransaction simulates, which fails for Anchor PDAs)
    console.log('[DroogGameClient.joinMatchWithStake] Using sign-then-send flow')
    const signedTx = await this.provider.wallet.signTransaction(tx)
    
    // Send the already-signed transaction
    const rawTx = signedTx.serialize()
    const signature = await this.connection.sendRawTransaction(rawTx, {
      skipPreflight: true, // Skip simulation since Privy embedded wallet may cause issues
      preflightCommitment: 'confirmed',
    })
    
    // Wait for confirmation
    await this.connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight,
    }, 'confirmed')
    
    console.log('[DroogGameClient.joinMatchWithStake] Match activated:', signature)
    return signature
  }

  /**
   * Cancel a pending match and refund Player A.
   * 
   * Can only be called:
   * - If status == Pending
   * - If Player B has not joined
   * - After CANCEL_TIMEOUT_SECONDS have elapsed
   */
  async cancelMatch(matchIdString: string): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    
    // Derive PDAs
    const [stakePDA] = DroogGameClient.deriveStakePDA(matchIdentity.hash32)
    const [escrowPDA] = DroogGameClient.deriveEscrowPDA(matchIdentity.hash32)
    const [escrowAuthPDA] = DroogGameClient.deriveEscrowAuthorityPDA(matchIdentity.hash32)
    
    // Get player A's wallet (current signer)
    const playerA = this.provider.wallet.publicKey
    
    // Get player A's token account
    const playerATokenAccount = await getAssociatedTokenAddress(
      PACKS_MINT,
      playerA,
      false,
      TOKEN_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID
    )
    
    const methods = this.program.methods as any
    
    const instruction = await methods
      .cancelMatch()
      .accounts({
        stakeState: stakePDA,
        mint: PACKS_MINT,
        playerATokenAccount: playerATokenAccount,
        escrowTokenAccount: escrowPDA,
        escrowAuthority: escrowAuthPDA,
        playerA: playerA,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      } as any)
      .instruction()
    
    // Create transaction and prepare it for signing
    const tx = new Transaction().add(instruction)
    
    // Get recent blockhash
    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed')
    tx.recentBlockhash = blockhash
    tx.feePayer = this.provider.wallet.publicKey
    
    // Use sign-then-send flow (Privy's signAndSendTransaction simulates, which fails for Anchor PDAs)
    console.log('[DroogGameClient.cancelMatch] Using sign-then-send flow')
    const signedTx = await this.provider.wallet.signTransaction(tx)
    
    // Send the already-signed transaction
    const rawTx = signedTx.serialize()
    const signature = await this.connection.sendRawTransaction(rawTx, {
      skipPreflight: true, // Skip simulation since Privy embedded wallet may cause issues
      preflightCommitment: 'confirmed',
    })
    
    // Wait for confirmation
    await this.connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight,
    }, 'confirmed')
    
    console.log('[DroogGameClient.cancelMatch] Match cancelled:', signature)
    return signature
  }

  /**
   * Check if Match PDA exists on-chain.
   * Used for real-time detection when waiting for the other player to create the PDA.
   * 
   * @param matchIdString - The string matchId
   * @param playerA - First player's public key
   * @param playerB - Second player's public key
   * @param commitment - Commitment level for the fetch (defaults to 'confirmed' for faster initialization; use 'finalized' for post-match verification)
   * @returns Promise resolving to MatchState if PDA exists, null otherwise
   */
  async checkMatchPDAExists(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    commitment: 'processed' | 'confirmed' | 'finalized' = 'confirmed'
  ): Promise<MatchState | null> {
    try {
      // Throttle to prevent 429 rate limiting
      await rpcThrottle.acquire()
      
      // Use canonical match identity for consistency
      const matchIdentity = await createMatchIdentity(matchIdString)
      const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
        matchIdentity.hash32,
        playerA,
        playerB
      )

      const account = await (this.program.account as any).matchState.fetch(matchPDA, commitment)
      
      return {
        matchId: account.matchId,
        startTs: account.startTs,
        endTs: account.endTs,
        playerA: account.playerA,
        playerB: account.playerB,
        customers: account.customers.map((c: any) => ({
          layer: c.layer,
          lastServedTs: c.lastServedTs,
          totalServes: c.totalServes,
          lastServedBy: c.lastServedBy,
        })),
        playerASales: account.playerASales.toNumber ? account.playerASales.toNumber() : account.playerASales,
        playerBSales: account.playerBSales.toNumber ? account.playerBSales.toNumber() : account.playerBSales,
        playerAReputation: account.playerAReputation.toNumber ? account.playerAReputation.toNumber() : account.playerAReputation,
        playerBReputation: account.playerBReputation.toNumber ? account.playerBReputation.toNumber() : account.playerBReputation,
        isFinalized: account.isFinalized,
      }
    } catch (error) {
      // PDA doesn't exist yet
      return null
    }
  }

  /**
   * Get player pubkeys from an existing match.
   * Helper to extract both player pubkeys from match state.
   * 
   * @param matchIdString - The string matchId
   * @param playerA - First player's public key (for PDA derivation)
   * @param playerB - Second player's public key (for PDA derivation)
   * @returns Promise resolving to [playerA, playerB] pubkeys from on-chain state
   */
  async getPlayerPubkeysFromMatch(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<[PublicKey, PublicKey] | null> {
    const matchState = await this.checkMatchPDAExists(matchIdString, playerA, playerB)
    if (!matchState) {
      return null
    }
    return [matchState.playerA, matchState.playerB]
  }

  /**
   * Initialize grow state for a match
   * Should be called after initMatch
   * 
   * Note: This uses retry logic with exponential backoff to handle 429 rate limiting.
   */
  async initGrowState(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    maxRetries = 3
  ): Promise<string> {
    // Throttle to prevent 429 rate limiting
    await rpcThrottle.acquire()
    
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const payer = this.provider.wallet.publicKey

    console.log('[initGrowState] Starting with:', {
      matchIdString,
      matchId: matchIdentity.u64.toString(),
      growStatePDA: growStatePDA.toBase58(),
      matchPDA: matchPDA.toBase58(),
      payer: payer.toBase58()
    })

    let lastError: any = null
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          // Exponential backoff: 500ms, 1000ms, 2000ms, etc.
          const delay = 500 * Math.pow(2, attempt - 1)
          console.log(`[initGrowState] Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms delay...`)
          await new Promise(resolve => setTimeout(resolve, delay))
          await rpcThrottle.acquire()
        }
        
        const tx = await (this.program.methods as any)
          .initGrowState(Array.from(matchIdentity.hash32), matchIdentity.u64)
          .accounts({
            growState: growStatePDA,
            matchState: matchPDA,
            payer,
            systemProgram: SystemProgram.programId,
          })
          .rpc()

        console.log('[initGrowState] Transaction successful:', tx)
        return tx
      } catch (error: any) {
        lastError = error
        const errorMessage = error?.message || String(error)
        
        // Check if this is a rate limit error (429)
        if (errorMessage.includes('429') || errorMessage.includes('Too many requests') || errorMessage.includes('rate limit')) {
          console.warn(`[initGrowState] Rate limited (429) on attempt ${attempt + 1}/${maxRetries}`)
          continue // Retry
        }
        
        // Check if PDA already exists (account already initialized)
        if (errorMessage.includes('already in use') || 
            error?.error?.errorCode?.code === 'AccountAlreadyExists' ||
            errorMessage.includes('0x0') // Anchor error for account already exists
        ) {
          console.log('[initGrowState] Grow state PDA already exists, skipping initialization')
          // Return a placeholder signature since the account already exists
          return 'already_initialized'
        }
        
        // For other errors, don't retry
        console.error('[initGrowState] Non-retryable error:', errorMessage)
        throw error
      }
    }
    
    // All retries exhausted
    console.error('[initGrowState] All retries exhausted, throwing last error')
    throw lastError
  }

  /**
   * Initialize delivery state for a match
   * Should be called after initMatch, before gameplay begins
   * 
   * Authority: Solana ONLY
   * - Delivery spots are selected deterministically
   * - Client cannot influence initial selection
   * 
   * Note: This uses retry logic with exponential backoff to handle 429 rate limiting.
   */
  async initDeliveryState(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    maxRetries = 3
  ): Promise<string> {
    // Throttle to prevent 429 rate limiting
    await rpcThrottle.acquire()
    
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchIdentity.u64)
    const payer = this.provider.wallet.publicKey

    console.log('[initDeliveryState] Starting with:', {
      matchIdString,
      matchId: matchIdentity.u64.toString(),
      deliveryStatePDA: deliveryStatePDA.toBase58(),
      matchPDA: matchPDA.toBase58(),
      payer: payer.toBase58()
    })

    let lastError: any = null
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          // Exponential backoff: 500ms, 1000ms, 2000ms, etc.
          const delay = 500 * Math.pow(2, attempt - 1)
          console.log(`[initDeliveryState] Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms delay...`)
          await new Promise(resolve => setTimeout(resolve, delay))
          await rpcThrottle.acquire()
        }
        
        const tx = await (this.program.methods as any)
          .initDeliveryState(Array.from(matchIdentity.hash32), matchIdentity.u64)
          .accounts({
            deliveryState: deliveryStatePDA,
            matchState: matchPDA,
            payer,
            systemProgram: SystemProgram.programId,
          })
          .rpc()

        console.log('[initDeliveryState] Transaction successful:', tx)
        return tx
      } catch (error: any) {
        lastError = error
        const errorMessage = error?.message || String(error)
        
        // Check if this is a rate limit error (429)
        if (errorMessage.includes('429') || errorMessage.includes('Too many requests') || errorMessage.includes('rate limit')) {
          console.warn(`[initDeliveryState] Rate limited (429) on attempt ${attempt + 1}/${maxRetries}`)
          continue // Retry
        }
        
        // Check if PDA already exists (account already initialized)
        if (errorMessage.includes('already in use') || 
            error?.error?.errorCode?.code === 'AccountAlreadyExists' ||
            errorMessage.includes('0x0') // Anchor error for account already exists
        ) {
          console.log('[initDeliveryState] Delivery state PDA already exists, skipping initialization')
          // Return a placeholder signature since the account already exists
          return 'already_initialized'
        }
        
        // For other errors, don't retry
        console.error('[initDeliveryState] Non-retryable error:', errorMessage)
        throw error
      }
    }
    
    // All retries exhausted
    console.error('[initDeliveryState] All retries exhausted, throwing last error')
    throw lastError
  }

  /**
   * Refresh delivery slots after 60-second rotation interval
   * 
   * Permissionless: Anyone can call this, but it only succeeds if:
   * - 60 seconds have passed since last refresh
   * - Match is still active
   * 
   * Authority: Solana ONLY
   * - Selection is purely deterministic from match_id + timestamp bucket
   */
  async refreshDeliverySlots(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchIdentity.u64)

    const tx = await (this.program.methods as any)
      .refreshDeliverySlots()
      .accounts({
        deliveryState: deliveryStatePDA,
        matchState: matchPDA,
      })
      .rpc()

    return tx
  }

  /**
   * Plant a strain in a grow slot
   * Automatically initializes grow state if it doesn't exist
   */
  async plantStrain(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    slotIndex: number,
    strainLevel: number
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    
    console.log('[DroogGameClient.plantStrain] Starting...', {
      matchIdString,
      slotIndex,
      strainLevel,
      playerA: playerA.toBase58(),
      playerB: playerB.toBase58(),
      matchIdU64: matchIdentity.u64.toString(),
      growStatePDA: growStatePDA.toBase58(),
    })
    
    const player = this.provider.wallet.publicKey

    // Check if grow state account exists
    let growStateAccountInfo = await this.provider.connection.getAccountInfo(growStatePDA)
    
    // Grow state must be initialized at match creation (no lazy initialization)
    if (!growStateAccountInfo) {
      throw new Error('Grow state not initialized. Grow state must be created during match initialization.')
    }

    // Fetch grow state to get the actual player_a and player_b stored on-chain
    // The plant_strain instruction derives match_state from grow_state, so we need
    // to use the same player order that's stored in grow_state
    const growState = await this.getGrowState(matchIdentity.u64)
    if (!growState) {
      throw new Error('Grow state account exists but could not be fetched')
    }

    // Derive match_state PDA using the players stored in grow_state
    // This ensures the PDA matches what the Rust instruction expects
    const growStatePlayerA = typeof growState.playerA === 'string' 
      ? new PublicKey(growState.playerA)
      : growState.playerA
    const growStatePlayerB = typeof growState.playerB === 'string'
      ? new PublicKey(growState.playerB)
      : growState.playerB
    
    // Get match_id_hash from grow_state (we need to fetch the raw account for this)
    // Actually, we can derive it from the matchIdentity.hash32 which should match
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      growStatePlayerA,
      growStatePlayerB
    )

    // Verify match_state account exists
    const matchStateAccountInfo = await this.provider.connection.getAccountInfo(matchPDA)

    try {
      console.log('[DroogGameClient.plantStrain] Sending transaction...')
      
      const tx = await (this.program.methods as any)
        .plantStrain(slotIndex, strainLevel)
        .accounts({
          growState: growStatePDA,
          matchState: matchPDA,
          player,
        })
        .rpc()

      console.log('[DroogGameClient.plantStrain] Transaction SUCCESS:', tx)
      return tx
    } catch (error: any) {
      // Enhanced error logging for debugging
      console.error('[DroogGameClient.plantStrain] Transaction failed:', {
        error: error.message,
        logs: error.logs,
        errorCode: error.error?.errorCode,
        programErrorStack: error.programErrorStack,
        slotIndex,
        strainLevel,
        player: player.toBase58(),
        matchPDA: matchPDA.toBase58(),
        growStatePDA: growStatePDA.toBase58(),
        clientPlayerA: playerA.toBase58(),
        clientPlayerB: playerB.toBase58(),
        growStatePlayerA: growStatePlayerA.toBase58(),
        growStatePlayerB: growStatePlayerB.toBase58(),
      })
      
      // Log transaction logs if available
      if (error.logs) {
        console.error('[DroogGameClient.plantStrain] Transaction logs:')
        error.logs.forEach((log: string) => console.error('  ', log))
      }
      
      throw error
    }
  }

  /**
   * Harvest a ready plant from a grow slot
   */
  async harvestStrain(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    slotIndex: number
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const player = this.provider.wallet.publicKey

    // Validate and convert slotIndex to u8 range
    if (slotIndex < 0 || slotIndex > 255 || !Number.isInteger(slotIndex)) {
      throw new Error(`Invalid slot index: ${slotIndex}. Must be an integer 0-255.`)
    }
    const slotIndexU8 = slotIndex & 0xFF // Ensure u8 range

    console.log('[DroogGameClient.harvestStrain] Starting...', {
      matchIdString,
      slotIndex,
      slotIndexU8,
      playerA: playerA.toBase58(),
      playerB: playerB.toBase58(),
      matchIdU64: matchIdentity.u64.toString(),
      growStatePDA: growStatePDA.toBase58(),
      matchPDA: matchPDA.toBase58(),
      player: player.toBase58(),
    })

    try {
      // Fetch current state BEFORE harvest for debugging
      const preHarvestState = await this.getGrowState(matchIdentity.u64, 'confirmed')
      if (preHarvestState) {
        const isPlayerA = player.toBase58() === preHarvestState.playerA?.toString()
        const relevantSlots = isPlayerA ? preHarvestState.playerASlots : preHarvestState.playerBSlots
        const targetSlot = relevantSlots?.[slotIndexU8]
        const inv = isPlayerA ? preHarvestState.playerAInventory : preHarvestState.playerBInventory
        console.log('[DroogGameClient.harvestStrain] PRE-HARVEST state:', {
          isPlayerA,
          slot: slotIndexU8,
          plantState: targetSlot?.plantState?.__kind || 'unknown',
          strainLevel: (targetSlot?.plantState as any)?.strainLevel,
          inventory: { L1: inv?.level1, L2: inv?.level2, L3: inv?.level3 },
        })
      }
      
      console.log('[DroogGameClient.harvestStrain] Sending transaction...')
      
      const tx = await (this.program.methods as any)
        .harvestStrain(slotIndexU8)
        .accounts({
          growState: growStatePDA,
          matchState: matchPDA,
          player,
        })
        .rpc()

      console.log('[DroogGameClient.harvestStrain] Transaction SUCCESS:', tx)
      
      // Wait for confirmation and check the result
      const connection = this.provider.connection
      const latestBlockhash = await connection.getLatestBlockhash('confirmed')
      const confirmation = await connection.confirmTransaction(
        {
          signature: tx,
          blockhash: latestBlockhash.blockhash,
          lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        },
        'confirmed'
      )
      
      if (confirmation.value.err) {
        console.error('[DroogGameClient.harvestStrain] Transaction confirmed but failed:', confirmation.value.err)
        throw new Error(`Transaction failed on-chain: ${JSON.stringify(confirmation.value.err)}`)
      }
      
      console.log('[DroogGameClient.harvestStrain] Transaction confirmed successfully')
      
      // Fetch current state AFTER harvest for debugging
      const postHarvestState = await this.getGrowState(matchIdentity.u64, 'confirmed')
      if (postHarvestState) {
        const isPlayerA = player.toBase58() === postHarvestState.playerA?.toString()
        const relevantSlots = isPlayerA ? postHarvestState.playerASlots : postHarvestState.playerBSlots
        const targetSlot = relevantSlots?.[slotIndexU8]
        const inv = isPlayerA ? postHarvestState.playerAInventory : postHarvestState.playerBInventory
        console.log('[DroogGameClient.harvestStrain] POST-HARVEST state:', {
          isPlayerA,
          slot: slotIndexU8,
          plantState: targetSlot?.plantState?.__kind || 'unknown',
          strainLevel: (targetSlot?.plantState as any)?.strainLevel,
          inventory: { L1: inv?.level1, L2: inv?.level2, L3: inv?.level3 },
        })
        
        // Warn if slot is not empty after successful harvest
        if (targetSlot?.plantState?.__kind !== 'Empty') {
          console.warn('[DroogGameClient.harvestStrain] WARNING: Slot is not Empty after harvest!',
            'Expected Empty, got:', targetSlot?.plantState?.__kind)
        }
      }
      
      return tx
    } catch (error: any) {
      // Enhanced error logging for debugging
      console.error('[DroogGameClient.harvestStrain] Transaction failed:', {
        error: error.message,
        logs: error.logs,
        errorCode: error.error?.errorCode,
        programErrorStack: error.programErrorStack,
        slotIndex,
        player: player.toBase58(),
        matchPDA: matchPDA.toBase58(),
        growStatePDA: growStatePDA.toBase58(),
      })
      
      // Log transaction logs if available
      if (error.logs) {
        console.error('[DroogGameClient.harvestStrain] Transaction logs:')
        error.logs.forEach((log: string) => console.error('  ', log))
      }
      
      throw error
    }
  }

  /**
   * Legacy harvest instruction (kept for backwards compatibility)
   * @deprecated Use harvestStrain instead
   */
  async harvest(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    strainId: number,
    plantedAt: number,
    lastHarvestedAt: number | null
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const player = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .harvest(
        strainId,
        new BN(plantedAt),
        lastHarvestedAt !== null ? new BN(lastHarvestedAt) : null
      )
      .accounts({
        matchState: matchPDA,
        player,
      })
      .rpc()

    return tx
  }

  /**
   * Sell to a customer
   * Requires grow state for inventory management AND delivery state for availability validation
   * 
   * Authority: Solana ONLY
   * - Validates customer is in current delivery rotation
   * - Client cannot bypass availability check
   */
  async sellToCustomer(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    customerIndex: number,
    strainLevel: number
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchIdentity.u64)
    const player = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .sellToCustomer(customerIndex, strainLevel)
      .accounts({
        matchState: matchPDA,
        growState: growStatePDA,
        deliveryState: deliveryStatePDA,
        player,
      })
      .rpc()

    return tx
  }

  /**
   * Finalize a match after it has ended and distribute stake to winner.
   * Can only be called once, after end_ts, by a match participant.
   * 
   * The winner is determined purely by sales count (on-chain authoritative).
   * Winner receives entire remaining escrow balance.
   */
  async finalizeMatch(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    
    // Derive staking PDAs
    const [stakePDA] = DroogGameClient.deriveStakePDA(matchIdentity.hash32)
    const [escrowPDA] = DroogGameClient.deriveEscrowPDA(matchIdentity.hash32)
    const [escrowAuthPDA] = DroogGameClient.deriveEscrowAuthorityPDA(matchIdentity.hash32)
    
    const player = this.provider.wallet.publicKey
    
    // Get match state to determine winner
    const matchState = await this.checkMatchPDAExists(matchIdString, playerA, playerB)
    if (!matchState) {
      throw new Error('Match state not found')
    }
    
    // Determine winner (same logic as on-chain: A wins ties)
    const winner = matchState.playerASales >= matchState.playerBSales 
      ? matchState.playerA 
      : matchState.playerB
    
    // Get winner's token account
    const winnerTokenAccount = await getAssociatedTokenAddress(
      PACKS_MINT,
      winner,
      false,
      TOKEN_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID
    )

    const tx = await (this.program.methods as any)
      .finalizeMatch()
      .accounts({
        matchState: matchPDA,
        stakeState: stakePDA,
        mint: PACKS_MINT,
        escrowTokenAccount: escrowPDA,
        escrowAuthority: escrowAuthPDA,
        winnerTokenAccount: winnerTokenAccount,
        player,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .rpc()

    return tx
  }

  /**
   * Fetch match state
   */
  async getMatchState(matchId: number): Promise<MatchState | null> {
    try {
      const [matchPDA] = DroogGameClient.deriveMatchPDA(matchId)
      const account = await (this.program.account as any).matchState.fetch(matchPDA)
      
        return {
          matchId: account.matchId,
          startTs: account.startTs,
          endTs: account.endTs,
          playerA: account.playerA,
          playerB: account.playerB,
          customers: account.customers.map((c: any) => ({
            layer: c.layer,
            lastServedTs: c.lastServedTs,
            totalServes: c.totalServes,
            lastServedBy: c.lastServedBy,
          })),
          playerASales: account.playerASales.toNumber ? account.playerASales.toNumber() : account.playerASales,
          playerBSales: account.playerBSales.toNumber ? account.playerBSales.toNumber() : account.playerBSales,
          playerAReputation: account.playerAReputation.toNumber ? account.playerAReputation.toNumber() : account.playerAReputation,
          playerBReputation: account.playerBReputation.toNumber ? account.playerBReputation.toNumber() : account.playerBReputation,
          isFinalized: account.isFinalized,
        }
    } catch (error) {
      console.error('Error fetching match state:', error)
      return null
    }
  }

  /**
   * Fetch grow state
   * 
   * @param matchId - The match ID
   * @param commitment - Commitment level for the fetch.
   *   - 'confirmed': Use after a transaction is confirmed for immediate state updates (faster)
   *   - 'finalized': Use for authoritative reads when adversarial safety matters (default)
   *   Note: For post-transaction refreshes, prefer 'confirmed' to avoid stale reads.
   * @returns Promise resolving to GrowState if PDA exists, null otherwise
   */
  async getGrowState(
    matchId: number | BN | bigint,
    commitment: 'processed' | 'confirmed' | 'finalized' = 'confirmed'
  ): Promise<GrowState | null> {
    try {
      // Throttle to prevent 429 rate limiting
      await rpcThrottle.acquire()
      
      const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchId)
      
      if (import.meta.env.DEV) {
        console.log('[getGrowState] Fetching from PDA:', growStatePDA.toBase58())
        console.log('[getGrowState] With matchId:', matchId.toString())
      }
      
      let account: any
      try {
        // Try Anchor's built-in fetch first
        account = await (this.program.account as any).matchGrowState.fetch(growStatePDA, commitment)
      } catch (anchorDecodeError: any) {
        // If Anchor's decoder fails (can happen with enum variants), try raw decode
        // This happens when Anchor's Union decoder has trouble with certain data patterns
        if (anchorDecodeError?.message?.includes('Cannot read properties of null') ||
            anchorDecodeError?.message?.includes('Union2.decode')) {
          console.warn('[getGrowState] Anchor decode failed, trying raw decode...', anchorDecodeError.message)
          
          // Fetch raw account data
          const rawAccount = await this.connection.getAccountInfo(growStatePDA, commitment)
          if (!rawAccount?.data) {
            console.warn('[getGrowState] Raw account fetch returned no data')
            return null
          }
          
          // Try to decode using the coder directly
          try {
            account = this.program.coder.accounts.decode('matchGrowState', rawAccount.data)
            console.log('[getGrowState] Raw decode succeeded')
          } catch (rawDecodeError: any) {
            console.warn('[getGrowState] Anchor coder decode failed, trying manual Borsh decode...', rawDecodeError.message)
            
            // Manual Borsh decode - bypasses Anchor's broken enum handling
            try {
              account = this.manualDecodeMatchGrowState(rawAccount.data)
              console.log('[getGrowState] Manual Borsh decode succeeded')
            } catch (manualDecodeError: any) {
              console.error('[getGrowState] Manual Borsh decode also failed:', manualDecodeError.message)
              // Return null to trigger retry - the on-chain state might still be propagating
              return null
            }
          }
        } else {
          // Re-throw non-decoder errors
          throw anchorDecodeError
        }
      }
      
      // Debug: log slot summary (condensed to reduce console spam)
      if (import.meta.env.DEV) {
        const getSlotsummary = (slots: any[]) => slots?.map((slot: any, i: number) => {
          const ps = slot.plantState || slot.plant_state
          const stateType = ps ? Object.keys(ps)[0] : '?'
          return `${i}:${stateType}`
        }).join(' ') || 'none'
        
        console.log('[getGrowState] Fetched state - A:', getSlotsummary(account.playerASlots), '| B:', getSlotsummary(account.playerBSlots))
      }
      
      const parseSlot = (slot: any): GrowSlot => {
        // Parse the new PlantState enum structure
        // Anchor serializes enums in multiple possible formats:
        // 1. { __kind: 'Growing', ... } - our normalized format
        // 2. { growing: { strainLevel: 1, plantedAt: ... } } - Anchor object format
        // 3. { discriminator: 1, ... } - discriminator format
        // Handle property name variations: plantState vs plant_state
        
        let plantState: PlantState
        const rawPlantState = slot.plantState || slot.plant_state
        
        if (rawPlantState) {
          // Check if it's already in our normalized format (__kind)
          if (rawPlantState.__kind) {
            plantState = rawPlantState
          }
          // Check for Anchor object format: { empty: {} }, { growing: {...} }, { ready: {...} }
          else if ('empty' in rawPlantState) {
            plantState = { __kind: 'Empty' }
          }
          else if ('growing' in rawPlantState) {
            const growingData = rawPlantState.growing
            plantState = { 
              __kind: 'Growing', 
              strainLevel: growingData.strainLevel ?? growingData.strain_level ?? 0,
              plantedAt: growingData.plantedAt ?? growingData.planted_at ?? new BN(0)
            }
          }
          else if ('ready' in rawPlantState) {
            const readyData = rawPlantState.ready
            plantState = { 
              __kind: 'Ready', 
              strainLevel: readyData.strainLevel ?? readyData.strain_level ?? 0
            }
          }
          // Check for discriminator format
          else if (rawPlantState.discriminator !== undefined) {
            const disc = rawPlantState.discriminator
            if (disc === 0) {
              plantState = { __kind: 'Empty' }
            } else if (disc === 1) {
              plantState = { 
                __kind: 'Growing', 
                strainLevel: rawPlantState.strainLevel || rawPlantState.strain_level || 0,
                plantedAt: rawPlantState.plantedAt || rawPlantState.planted_at || new BN(0)
              }
            } else if (disc === 2) {
              plantState = { 
                __kind: 'Ready', 
                strainLevel: rawPlantState.strainLevel || rawPlantState.strain_level || 0
              }
            } else {
              plantState = { __kind: 'Empty' }
            }
          }
          // Try to infer from structure (legacy inference)
          else if ('plantedAt' in rawPlantState || 'planted_at' in rawPlantState) {
            plantState = {
              __kind: 'Growing',
              strainLevel: rawPlantState.strainLevel || rawPlantState.strain_level || slot.strainLevel || 0,
              plantedAt: rawPlantState.plantedAt || rawPlantState.planted_at || new BN(0)
            }
          } 
          else if ('strainLevel' in rawPlantState || 'strain_level' in rawPlantState) {
            plantState = {
              __kind: 'Ready',
              strainLevel: rawPlantState.strainLevel || rawPlantState.strain_level || slot.strainLevel || 0
            }
          } 
          else {
            // Empty object means Empty variant
            plantState = { __kind: 'Empty' }
          }
        } else {
          // No plantState/plant_state field - check legacy format (old on-chain structure)
          // Legacy format has: occupied, strainLevel, variantId, plantedTs, readyTs, harvested
          if (slot.occupied) {
            // Legacy: slot is occupied
            const legacyPlantedTs = slot.plantedTs 
              ? (typeof slot.plantedTs === 'number' ? slot.plantedTs : 
                 (slot.plantedTs.toNumber ? slot.plantedTs.toNumber() : Number(slot.plantedTs)))
              : 0
            const legacyReadyTs = slot.readyTs 
              ? (typeof slot.readyTs === 'number' ? slot.readyTs : 
                 (slot.readyTs.toNumber ? slot.readyTs.toNumber() : Number(slot.readyTs)))
              : 0
            const legacyStrainLevel = slot.strainLevel || slot.strain_level || 0
            
            // Check if harvested
            if (slot.harvested) {
              // Harvested plants go back to Empty
              plantState = { __kind: 'Empty' }
            } else {
              // Check if ready by comparing planted_ts + growth_time vs current time
              // We can't check current time here, so use readyTs from chain
              const currentTs = Date.now() / 1000
              if (legacyReadyTs > 0 && currentTs >= legacyReadyTs) {
                plantState = { __kind: 'Ready', strainLevel: legacyStrainLevel }
              } else if (legacyPlantedTs > 0) {
                plantState = { 
                  __kind: 'Growing', 
                  strainLevel: legacyStrainLevel,
                  plantedAt: new BN(legacyPlantedTs)
                }
              } else {
                // Fallback - should not happen
                plantState = { __kind: 'Empty' }
              }
            }
          } else {
            // Legacy: slot is not occupied
            plantState = { __kind: 'Empty' }
          }
        }
        
        // Extract values based on plant state
        let occupied = false
        let plantedTs: BN = new BN(0)
        let readyTs: BN = new BN(0)
        let harvested = false
        
        if (plantState.__kind === 'Growing') {
          occupied = true
          const plantedAt = plantState.plantedAt
          plantedTs = typeof plantedAt === 'number' 
            ? new BN(plantedAt) 
            : (plantedAt instanceof BN ? plantedAt : new BN(plantedAt))
          // Calculate readyTs from planted_at + growth_time
          const growthTime = GROWTH_TIMES[plantState.strainLevel as 1 | 2 | 3] || 0
          readyTs = plantedTs.add(new BN(growthTime))
        } else if (plantState.__kind === 'Ready') {
          occupied = true
          // For Ready state, we don't have planted_at anymore
          // Calculate backwards: if it's ready now, planted_at was (current_time - growth_time)
          // But we don't have current_time here, so we'll set readyTs to 0 (meaning "already ready")
          // The UI will handle this by checking if currentTs >= readyTs (which will always be true)
          plantedTs = new BN(0)
          readyTs = new BN(0) // Set to 0 to indicate "already ready"
        } else {
          // Empty state - slot is available for planting
          occupied = false
          plantedTs = new BN(0)
          readyTs = new BN(0)
          harvested = false
        }
        
        const parsedSlot: GrowSlot = {
          // New structure
          plantState,
          strainLevel: slot.strainLevel ?? slot.strain_level ?? 0,
          variantId: slot.variantId ?? slot.variant_id ?? 0,
          lastHarvestedTs: (() => {
            const ts = slot.lastHarvestedTs ?? slot.last_harvested_ts
            if (!ts) return new BN(0)
            return typeof ts === 'number' 
              ? new BN(ts) 
              : (ts instanceof BN ? ts : new BN(ts))
          })(),
          
          // Legacy fields for backward compatibility
          occupied,
          plantedTs,
          readyTs,
          harvested,
        }
        
        return parsedSlot
      }

      const parseInventory = (inv: any): Inventory => ({
        level1: inv.level1,
        level2: inv.level2,
        level3: inv.level3,
      })

      return {
        matchId: account.matchId,
        playerA: account.playerA,
        playerB: account.playerB,
        playerASlots: account.playerASlots.map(parseSlot),
        playerBSlots: account.playerBSlots.map(parseSlot),
        playerAInventory: parseInventory(account.playerAInventory),
        playerBInventory: parseInventory(account.playerBInventory),
      }
    } catch (error: any) {
      // Don't log "account does not exist" errors - this is expected during initialization
      const errorMessage = error?.message || error?.toString() || ''
      const isAccountNotFound = 
        errorMessage.includes('Account does not exist') ||
        errorMessage.includes('has no data') ||
        errorMessage.includes('could not find account')
      
      if (!isAccountNotFound) {
        console.error('Error fetching grow state:', error)
      }
      return null
    }
  }

  /**
   * Manual Borsh decoder for MatchGrowState.
   * This bypasses Anchor's coder which has issues with nested enum variants in Anchor 0.32+.
   * 
   * Account layout (359 bytes total):
   * - 8 bytes: Anchor discriminator
   * - 8 bytes: match_id (u64 LE)
   * - 32 bytes: match_id_hash ([u8; 32])
   * - 32 bytes: player_a (Pubkey)
   * - 32 bytes: player_b (Pubkey)
   * - 6 × GrowSlot: player_a_slots (variable size each, up to 20 bytes)
   * - 6 × GrowSlot: player_b_slots (variable size each, up to 20 bytes)
   * - 3 bytes: player_a_inventory (level1, level2, level3)
   * - 3 bytes: player_b_inventory (level1, level2, level3)
   * - 1 byte: bump
   * 
   * GrowSlot layout (variable, up to 20 bytes):
   * - PlantState: 1-10 bytes depending on variant
   * - 1 byte: strain_level
   * - 1 byte: variant_id
   * - 8 bytes: last_harvested_ts (i64 LE)
   * 
   * PlantState enum (Borsh serialization):
   * - Empty (0): 1 byte discriminator only
   * - Growing (1): 1 byte disc + 1 byte strain_level + 8 bytes planted_at (i64 LE)
   * - Ready (2): 1 byte disc + 1 byte strain_level
   */
  private manualDecodeMatchGrowState(data: Buffer | Uint8Array): any {
    // Ensure we're working with a proper Buffer
    const buf = Buffer.isBuffer(data) ? data : Buffer.from(data)
    
    let offset = 0
    
    // Debug: log raw account data info
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] Raw data type:', data.constructor.name)
      console.log('[manualDecodeMatchGrowState] Raw data length:', buf.length)
      console.log('[manualDecodeMatchGrowState] First 16 bytes (hex):', buf.subarray(0, 16).toString('hex'))
      console.log('[manualDecodeMatchGrowState] Bytes 112-128 (start of slots, hex):', buf.subarray(112, 128).toString('hex'))
    }
    
    // Helper to read bytes
    const readBytes = (len: number): Buffer => {
      const slice = Buffer.from(buf.subarray(offset, offset + len))
      offset += len
      return slice
    }
    
    // Helper to read u8
    const readU8 = (): number => {
      const val = buf[offset]
      offset += 1
      return val
    }
    
    // Helper to read u64 LE
    const readU64LE = (): BN => {
      const bytes = readBytes(8)
      // Convert to BN from little-endian bytes
      return new BN(bytes, 'le')
    }
    
    // Helper to read i64 LE
    const readI64LE = (): BN => {
      const bytes = readBytes(8)
      // Debug: log the bytes being read for i64
      if (import.meta.env.DEV && offset <= 172) { // Only log for first few reads
        console.log(`[readI64LE] offset=${offset - 8}, bytes=${bytes.toString('hex')}`)
      }
      // BN from little-endian, but need to handle sign
      // For simplicity, treat as unsigned since our timestamps are positive
      return new BN(bytes, 'le')
    }
    
    // Helper to read Pubkey (32 bytes)
    const readPubkey = (): PublicKey => {
      const buf = readBytes(32)
      return new PublicKey(buf)
    }
    
    // Helper to decode PlantState
    // EMPIRICALLY DETERMINED: PlantState appears to be 11 bytes for Growing variant
    // This includes an extra byte after strain_level (possibly variant_id duplication or padding)
    // PlantState variants: Empty (1 byte + 10 padding = 11), Ready (2 bytes + 9 padding = 11), Growing (11 bytes)
    // After reading the variant data, we must skip any padding to reach exactly 11 bytes
    const PLANT_STATE_SIZE = 11 // Empirically determined from on-chain data analysis
    
    const decodePlantState = (slotLabel: string): PlantState => {
      const startOffset = offset
      const discriminator = readU8()
      
      if (import.meta.env.DEV && discriminator > 2) {
        console.warn(`[manualDecodeMatchGrowState] ${slotLabel}: Unknown discriminator ${discriminator} at offset ${startOffset}, raw bytes: ${buf.subarray(startOffset, startOffset + 16).toString('hex')}`)
      }
      
      let result: PlantState
      let bytesRead = 1 // discriminator already read
      
      switch (discriminator) {
        case 0: // Empty - just discriminator (1 byte used)
          result = { __kind: 'Empty' }
          break
        case 1: { // Growing - discriminator + strain_level + planted_at (1 + 1 + 8 = 10 bytes)
          const strainLevel = readU8()
          // WORKAROUND: There appears to be an extra byte before planted_at in the on-chain data
          // Skip this byte to read the timestamp correctly
          // TODO: Investigate why Borsh serialization includes this extra byte
          const mysteryByte = readU8()
          if (import.meta.env.DEV) {
            console.log(`[manualDecodeMatchGrowState] ${slotLabel}: Growing mystery byte=${mysteryByte.toString(16)}`)
          }
          const plantedAt = readI64LE()
          bytesRead += 10 // 1 (strainLevel) + 1 (mystery) + 8 (plantedAt)
          if (import.meta.env.DEV) {
            console.log(`[manualDecodeMatchGrowState] ${slotLabel}: Growing, strainLevel=${strainLevel}, plantedAt=${plantedAt.toString()}`)
          }
          result = { __kind: 'Growing', strainLevel, plantedAt }
          break
        }
        case 2: { // Ready - discriminator + strain_level (1 + 1 = 2 bytes)
          const strainLevel = readU8()
          bytesRead += 1
          result = { __kind: 'Ready', strainLevel }
          break
        }
        default:
          console.warn(`[manualDecodeMatchGrowState] ${slotLabel}: Unknown PlantState discriminator: ${discriminator} at offset ${startOffset}, treating as Empty`)
          result = { __kind: 'Empty' }
          break
      }
      
      // Skip padding to ensure we always consume exactly PLANT_STATE_SIZE bytes
      const paddingToSkip = PLANT_STATE_SIZE - bytesRead
      if (paddingToSkip > 0) {
        offset += paddingToSkip
      }
      
      return result
    }
    
    // Helper to decode GrowSlot
    // EMPIRICAL LAYOUT (20 bytes total):
    // - PlantState: 11 bytes (with mystery byte after Growing.strain_level)
    // - variant_id: 1 byte
    // - last_harvested_ts: 8 bytes
    // Note: GrowSlot.strain_level appears to be embedded in PlantState for Growing variant
    const decodeGrowSlot = (slotLabel: string): any => {
      const slotStartOffset = offset
      
      // Debug: show raw bytes for this slot
      if (import.meta.env.DEV) {
        console.log(`[manualDecodeMatchGrowState] ${slotLabel}: raw bytes at offset ${slotStartOffset}:`, 
          buf.subarray(slotStartOffset, slotStartOffset + 20).toString('hex'))
      }
      
      const plantState = decodePlantState(slotLabel)
      // For Growing, the strain_level is already embedded in the mystery byte read during PlantState
      // For other states, we still need to read the remaining slot fields
      const variantId = readU8()
      const lastHarvestedTs = readI64LE()
      
      // Derive strain_level from plantState for Growing, otherwise from variantId position
      const strainLevel = plantState.__kind === 'Growing' ? plantState.strainLevel :
                          plantState.__kind === 'Ready' ? plantState.strainLevel : 0
      
      if (import.meta.env.DEV) {
        console.log(`[manualDecodeMatchGrowState] ${slotLabel}: offset=${slotStartOffset}, plantState=${plantState.__kind}, strainLevel=${strainLevel}, variantId=${variantId}, offsetAfter=${offset}`)
      }
      
      return {
        plantState,
        plant_state: plantState, // Add snake_case alias for compatibility
        strainLevel,
        strain_level: strainLevel,
        variantId,
        variant_id: variantId,
        lastHarvestedTs,
        last_harvested_ts: lastHarvestedTs,
      }
    }
    
    // Helper to decode Inventory (3 bytes)
    const decodeInventory = (): Inventory => ({
      level1: readU8(),
      level2: readU8(),
      level3: readU8(),
    })
    
    // Skip Anchor account discriminator (8 bytes)
    const anchorDiscriminator = readBytes(8)
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] Anchor discriminator (hex):', anchorDiscriminator.toString('hex'))
      console.log('[manualDecodeMatchGrowState] Current offset after discriminator:', offset)
    }
    
    // Read match_id (u64)
    const matchId = readU64LE()
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] matchId:', matchId.toString(), 'offset now:', offset)
    }
    
    // Read match_id_hash (32 bytes) - we don't use this but need to skip
    const matchIdHash = readBytes(32)
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] match_id_hash first 4 bytes:', matchIdHash.subarray(0, 4).toString('hex'), 'offset now:', offset)
    }
    
    // Read player_a (32 bytes)
    const playerA = readPubkey()
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] playerA:', playerA.toBase58(), 'offset now:', offset)
    }
    
    // Read player_b (32 bytes)
    const playerB = readPubkey()
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] playerB:', playerB.toBase58(), 'offset now:', offset)
    }
    
    // Read player_a_slots (6 GrowSlots)
    const playerASlots: any[] = []
    if (import.meta.env.DEV) {
      console.log(`[manualDecodeMatchGrowState] Starting player_a_slots at offset: ${offset}`)
    }
    for (let i = 0; i < 6; i++) {
      playerASlots.push(decodeGrowSlot(`A${i}`))
    }
    
    // Read player_b_slots (6 GrowSlots)
    const playerBSlots: any[] = []
    if (import.meta.env.DEV) {
      console.log(`[manualDecodeMatchGrowState] Starting player_b_slots at offset: ${offset}`)
    }
    for (let i = 0; i < 6; i++) {
      playerBSlots.push(decodeGrowSlot(`B${i}`))
    }
    
    // Read player_a_inventory
    const playerAInventory = decodeInventory()
    
    // Read player_b_inventory
    const playerBInventory = decodeInventory()
    
    // Read bump (1 byte) - we don't need this
    const bump = readU8()
    
    if (import.meta.env.DEV) {
      console.log('[manualDecodeMatchGrowState] Successfully decoded:', {
        matchId: matchId.toString(),
        playerA: playerA.toBase58(),
        playerB: playerB.toBase58(),
        playerASlots: playerASlots.map((s, i) => `${i}:${s.plantState.__kind}`),
        playerBSlots: playerBSlots.map((s, i) => `${i}:${s.plantState.__kind}`),
        bytesRead: offset,
        totalBytes: data.length,
      })
    }
    
    return {
      matchId,
      matchIdHash,
      playerA,
      playerB,
      playerASlots,
      playerBSlots,
      playerAInventory,
      playerBInventory,
      bump,
    }
  }

  /**
   * Fetch delivery state
   * 
   * Returns the current on-chain delivery availability state.
   * This is the AUTHORITATIVE source of which customers are available.
   * 
   * @param matchId - The match ID (supports number, BN, or bigint to avoid precision loss)
   * @returns Promise resolving to DeliveryState if PDA exists, null otherwise
   */
  async getDeliveryState(matchId: number | BN | bigint): Promise<DeliveryState | null> {
    try {
      // Throttle to prevent 429 rate limiting
      await rpcThrottle.acquire()
      
      const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchId)
      const account = await (this.program.account as any).matchDeliveryState.fetch(deliveryStatePDA)
      
      // Filter out invalid indices (255)
      const availableCustomers: number[] = []
      for (let i = 0; i < account.activeCount; i++) {
        const idx = account.availableCustomers[i]
        if (idx !== 255) {
          availableCustomers.push(idx)
        }
      }

      return {
        matchId: account.matchId,
        lastUpdateTs: account.lastUpdateTs,
        availableCustomers,
        activeCount: account.activeCount,
      }
    } catch (error: any) {
      // Don't log "account does not exist" errors - this is expected during initialization
      const errorMessage = error?.message || error?.toString() || ''
      const isAccountNotFound = 
        errorMessage.includes('Account does not exist') ||
        errorMessage.includes('has no data') ||
        errorMessage.includes('could not find account')
      
      if (!isAccountNotFound) {
        console.error('Error fetching delivery state:', error)
      }
      return null
    }
  }

  /**
   * Check if customer is available (cooldown passed)
   * Uses match-anchored time to prevent clock drift issues
   */
  async isCustomerAvailable(matchId: number, customerIndex: number): Promise<boolean> {
    const matchState = await this.getMatchState(matchId)
    if (!matchState) return false

    const customer = matchState.customers[customerIndex]
    if (!customer) return false

    // If never served, available
    if (customer.lastServedTs.toNumber() === 0) return true

    // Check cooldown using match-anchored time
    const cooldowns = [30, 45, 75] // Layer 1, 2, 3 in seconds
    const cooldown = cooldowns[customer.layer - 1] || 0
    const matchStartTs = matchState.startTs.toNumber()
    const currentTs = getCurrentMatchTime(matchStartTs)
    const timeSinceLastServe = currentTs - customer.lastServedTs.toNumber()

    return timeSinceLastServe >= cooldown
  }

  /**
   * Check if planting is allowed (not in endgame lock)
   */
  canPlant(matchStartTs: number, matchEndTs: number, currentTs?: number): boolean {
    const now = currentTs ?? getCurrentMatchTime(matchStartTs)
    return now < matchEndTs - ENDGAME_LOCK_SECONDS
  }

  /**
   * Check if a plant will be ready before match ends
   */
  willBeReadyInTime(
    matchEndTs: number,
    strainLevel: 1 | 2 | 3,
    currentTs: number
  ): boolean {
    const growthTime = GROWTH_TIMES[strainLevel]
    const readyTs = currentTs + growthTime
    return readyTs <= matchEndTs
  }

  /**
   * Compute smell for a player's slots (client-side, for UI only)
   */
  computeSmell(slots: GrowSlot[], currentTs: number): number {
    return slots
      .filter(s => s.occupied && !s.harvested)
      .reduce((total, slot) => {
        const plantedTs = slot.plantedTs.toNumber ? slot.plantedTs.toNumber() : slot.plantedTs
        const elapsedSecs = Math.max(0, currentTs - plantedTs)
        const elapsedMins = Math.floor(elapsedSecs / 60)
        const rate = SMELL_RATES[slot.strainLevel as 1 | 2 | 3] || 0
        return total + (elapsedMins * rate)
      }, 0)
  }

  /**
   * Subscribe to match state changes
   */
  subscribeToMatchState(
    matchId: number,
    callback: (matchState: MatchState | null) => void
  ): number {
    const [matchPDA] = DroogGameClient.deriveMatchPDA(matchId)
    
    const subscriptionId = this.connection.onAccountChange(
      matchPDA,
      (accountInfo) => {
        try {
          const matchState = this.program.coder.accounts.decode(
            'matchState',
            accountInfo.data
          ) as any
          
          callback({
            matchId: matchState.matchId,
            startTs: matchState.startTs,
            endTs: matchState.endTs,
            playerA: matchState.playerA,
            playerB: matchState.playerB,
            customers: matchState.customers.map((c: any) => ({
              layer: c.layer,
              lastServedTs: c.lastServedTs,
              totalServes: c.totalServes,
              lastServedBy: c.lastServedBy,
            })),
            playerASales: matchState.playerASales.toNumber ? matchState.playerASales.toNumber() : matchState.playerASales,
            playerBSales: matchState.playerBSales.toNumber ? matchState.playerBSales.toNumber() : matchState.playerBSales,
            playerAReputation: matchState.playerAReputation.toNumber ? matchState.playerAReputation.toNumber() : matchState.playerAReputation,
            playerBReputation: matchState.playerBReputation.toNumber ? matchState.playerBReputation.toNumber() : matchState.playerBReputation,
            isFinalized: matchState.isFinalized,
          })
        } catch (error) {
          console.error('Error decoding match state:', error)
          callback(null)
        }
      },
      'confirmed'
    )

    return subscriptionId
  }

  /**
   * Subscribe to grow state changes
   */
  subscribeToGrowState(
    matchId: number | BN | bigint,
    callback: (growState: GrowState | null) => void
  ): number {
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchId)
    
    const subscriptionId = this.connection.onAccountChange(
      growStatePDA,
      (accountInfo) => {
        try {
          const growState = this.program.coder.accounts.decode(
            'matchGrowState',
            accountInfo.data
          ) as any
          
          const parseSlot = (slot: any): GrowSlot => {
            // Parse the new PlantState enum structure
            // Anchor serializes enums as objects with __kind field (or discriminator)
            // Handle both possible formats
            let plantState: PlantState
            if (slot.plantState) {
              // Check if it's already in the expected format
              if (slot.plantState.__kind) {
                plantState = slot.plantState
              } else if (slot.plantState.discriminator !== undefined) {
                // Alternative format: use discriminator
                const disc = slot.plantState.discriminator
                if (disc === 0) {
                  plantState = { __kind: 'Empty' }
                } else if (disc === 1) {
                  plantState = { 
                    __kind: 'Growing', 
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || 0,
                    plantedAt: slot.plantState.plantedAt || slot.plantState.planted_at || new BN(0)
                  }
                } else if (disc === 2) {
                  plantState = { 
                    __kind: 'Ready', 
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || 0
                  }
                } else {
                  plantState = { __kind: 'Empty' }
                }
              } else {
                // Try to infer from structure
                if ('plantedAt' in slot.plantState || 'planted_at' in slot.plantState) {
                  plantState = {
                    __kind: 'Growing',
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || slot.strainLevel || 0,
                    plantedAt: slot.plantState.plantedAt || slot.plantState.planted_at || new BN(0)
                  }
                } else if ('strainLevel' in slot.plantState || 'strain_level' in slot.plantState) {
                  plantState = {
                    __kind: 'Ready',
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || slot.strainLevel || 0
                  }
                } else {
                  plantState = { __kind: 'Empty' }
                }
              }
            } else {
              // No plantState field - check legacy format (old on-chain structure)
              // Legacy format has: occupied, strainLevel, variantId, plantedTs, readyTs, harvested
              if (slot.occupied) {
                // Legacy: slot is occupied
                const legacyPlantedTs = slot.plantedTs 
                  ? (typeof slot.plantedTs === 'number' ? slot.plantedTs : 
                     (slot.plantedTs.toNumber ? slot.plantedTs.toNumber() : Number(slot.plantedTs)))
                  : 0
                const legacyReadyTs = slot.readyTs 
                  ? (typeof slot.readyTs === 'number' ? slot.readyTs : 
                     (slot.readyTs.toNumber ? slot.readyTs.toNumber() : Number(slot.readyTs)))
                  : 0
                const legacyStrainLevel = slot.strainLevel || slot.strain_level || 0
                
                // Check if harvested
                if (slot.harvested) {
                  // Harvested plants go back to Empty
                  plantState = { __kind: 'Empty' }
                } else {
                  // Check if ready by comparing current time vs readyTs
                  const currentTs = Date.now() / 1000
                  if (legacyReadyTs > 0 && currentTs >= legacyReadyTs) {
                    plantState = { __kind: 'Ready', strainLevel: legacyStrainLevel }
                  } else if (legacyPlantedTs > 0) {
                    plantState = { 
                      __kind: 'Growing', 
                      strainLevel: legacyStrainLevel,
                      plantedAt: new BN(legacyPlantedTs)
                    }
                  } else {
                    // Fallback - should not happen
                    plantState = { __kind: 'Empty' }
                  }
                }
              } else {
                // Legacy: slot is not occupied
                plantState = { __kind: 'Empty' }
              }
            }
            
            // Extract values based on plant state
            let occupied = false
            let plantedTs: BN = new BN(0)
            let readyTs: BN = new BN(0)
            let harvested = false
            
            if (plantState.__kind === 'Growing') {
              occupied = true
              const plantedAt = plantState.plantedAt
              plantedTs = typeof plantedAt === 'number' 
                ? new BN(plantedAt) 
                : (plantedAt instanceof BN ? plantedAt : new BN(plantedAt))
              // Calculate readyTs from planted_at + growth_time
              const growthTime = GROWTH_TIMES[plantState.strainLevel as 1 | 2 | 3] || 0
              readyTs = plantedTs.add(new BN(growthTime))
            } else if (plantState.__kind === 'Ready') {
              occupied = true
              plantedTs = new BN(0)
              readyTs = new BN(0) // Set to 0 to indicate "already ready"
            } else {
              // Empty state
              occupied = false
              plantedTs = new BN(0)
              readyTs = new BN(0)
              harvested = false
            }
            
            return {
              // New structure
              plantState,
              strainLevel: slot.strainLevel || 0,
              variantId: slot.variantId || 0,
              lastHarvestedTs: slot.lastHarvestedTs 
                ? (typeof slot.lastHarvestedTs === 'number' 
                    ? new BN(slot.lastHarvestedTs) 
                    : (slot.lastHarvestedTs instanceof BN ? slot.lastHarvestedTs : new BN(slot.lastHarvestedTs)))
                : new BN(0),
              
              // Legacy fields for backward compatibility
              occupied,
              plantedTs,
              readyTs,
              harvested,
            }
          }

          const parseInventory = (inv: any): Inventory => ({
            level1: inv.level1,
            level2: inv.level2,
            level3: inv.level3,
          })

          callback({
            matchId: growState.matchId,
            playerA: growState.playerA,
            playerB: growState.playerB,
            playerASlots: growState.playerASlots.map(parseSlot),
            playerBSlots: growState.playerBSlots.map(parseSlot),
            playerAInventory: parseInventory(growState.playerAInventory),
            playerBInventory: parseInventory(growState.playerBInventory),
          })
        } catch (error) {
          console.error('Error decoding grow state:', error)
          callback(null)
        }
      },
      'confirmed'
    )

    return subscriptionId
  }

  /**
   * Subscribe to delivery state changes
   * 
   * This allows the client to react to on-chain delivery rotations.
   * The on-chain state is AUTHORITATIVE.
   */
  subscribeToDeliveryState(
    matchId: number,
    callback: (deliveryState: DeliveryState | null) => void
  ): number {
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchId)
    
    const subscriptionId = this.connection.onAccountChange(
      deliveryStatePDA,
      (accountInfo) => {
        try {
          const deliveryState = this.program.coder.accounts.decode(
            'matchDeliveryState',
            accountInfo.data
          ) as any
          
          // Filter out invalid indices (255)
          const availableCustomers: number[] = []
          for (let i = 0; i < deliveryState.activeCount; i++) {
            const idx = deliveryState.availableCustomers[i]
            if (idx !== 255) {
              availableCustomers.push(idx)
            }
          }

          callback({
            matchId: deliveryState.matchId,
            lastUpdateTs: deliveryState.lastUpdateTs,
            availableCustomers,
            activeCount: deliveryState.activeCount,
          })
        } catch (error) {
          console.error('Error decoding delivery state:', error)
          callback(null)
        }
      },
      'confirmed'
    )

    return subscriptionId
  }

  /**
   * Unsubscribe from match state changes
   */
  unsubscribeFromMatchState(subscriptionId: number): Promise<void> {
    return this.connection.removeAccountChangeListener(subscriptionId)
  }

  /**
   * Unsubscribe from grow state changes
   */
  unsubscribeFromGrowState(subscriptionId: number): Promise<void> {
    return this.connection.removeAccountChangeListener(subscriptionId)
  }

  /**
   * Unsubscribe from delivery state changes
   */
  unsubscribeFromDeliveryState(subscriptionId: number): Promise<void> {
    return this.connection.removeAccountChangeListener(subscriptionId)
  }

  /**
   * Check if a customer is currently available for delivery
   * 
   * Uses on-chain delivery state (AUTHORITATIVE).
   * This is different from cooldown availability.
   */
  async isCustomerAvailableForDelivery(matchId: number, customerIndex: number): Promise<boolean> {
    const deliveryState = await this.getDeliveryState(matchId)
    if (!deliveryState) return false
    return deliveryState.availableCustomers.includes(customerIndex)
  }
}

/**
 * Create a wallet from a keypair or signer
 */
export function createWalletFromKeypair(keypair: any): Wallet {
  return {
    publicKey: keypair.publicKey,
    signTransaction: async <T extends Transaction>(tx: T): Promise<T> => {
      (tx as Transaction).sign(keypair)
      return tx
    },
    signAllTransactions: async <T extends Transaction>(txs: T[]): Promise<T[]> => {
      txs.forEach(tx => (tx as Transaction).sign(keypair))
      return txs
    },
  } as Wallet
}

// Extended wallet interface that includes sendRawTransaction for Privy
export interface PrivyWallet extends Wallet {
  signAndSendTransaction?: (tx: Transaction) => Promise<{ signature: string }>
  privyWalletRef?: any
  signAndSendTransactionFn?: any
}

/**
 * Create a wallet from a Privy Solana wallet
 * Ensures proper structure for Anchor's Wallet interface
 * 
 * This is critical for Privy integration - Privy wallets have a different
 * structure than standard Solana wallets and must be wrapped correctly.
 * 
 * IMPORTANT: The privyWallet parameter must be the FULL ConnectedStandardSolanaWallet
 * object from useWallets(), not just { address: string }. This is required for
 * signAndSendTransaction to work correctly with Privy's embedded wallet service.
 * 
 * @param privyWallet - The Privy wallet from useWallets() hook (must be full ConnectedStandardSolanaWallet)
 * @param signTransactionFn - The signTransaction function from useSignTransaction() hook (REQUIRED)
 * @param signAllTransactionsFn - Optional signAllTransactions function from useSignAllTransactions() hook
 * @param signAndSendTransactionFn - Optional signAndSendTransaction function from useSignAndSendTransaction() hook
 */
export function createWalletFromPrivyWallet(
  // Accept the full wallet object - needed for signAndSendTransaction
  privyWallet: any,
  // Note: We accept any signTransaction function that takes a transaction input.
  // We serialize Transaction objects to Uint8Array before calling this function,
  // so any compatible Privy signTransaction function will work.
  signTransactionFn: ((input: {
    transaction: Uint8Array | Transaction
    wallet: any
    chain?: string // Optional chain parameter (e.g., 'solana:devnet')
  }) => Promise<{ signedTransaction: Uint8Array }>) | ((...args: any[]) => Promise<any>),
  signAllTransactionsFn?: ((input: {
    transactions: (Uint8Array | Transaction)[]
    wallet: any
    chain?: string // Optional chain parameter (e.g., 'solana:devnet')
  }) => Promise<{ signedTransactions: Uint8Array[] }>) | ((...args: any[]) => Promise<any>),
  signAndSendTransactionFn?: ((input: {
    transaction: Uint8Array | Transaction
    wallet: any
    chain?: string
  }) => Promise<{ signature: Uint8Array }>) | ((...args: any[]) => Promise<any>)
): PrivyWallet {
  if (!privyWallet.address) {
    throw new Error('Privy wallet address is required')
  }
  
  // Validate address is a valid Solana public key
  let publicKey: PublicKey
  try {
    publicKey = new PublicKey(privyWallet.address)
  } catch (error) {
    throw new Error(`Invalid Solana public key: ${privyWallet.address}`)
  }
  
  // signTransactionFn is REQUIRED
  if (!signTransactionFn || typeof signTransactionFn !== 'function') {
    throw new Error(
      'signTransaction function from useSignTransaction() hook is required. ' +
      'Pass it as the second parameter to createWalletFromPrivyWallet().'
    )
  }

  // Debug logging
  console.log('[createWalletFromPrivyWallet] Wrapping Privy wallet:', {
    address: privyWallet.address,
    publicKey: publicKey.toString(),
    hasSignTransactionFn: typeof signTransactionFn === 'function',
    hasSignAllTransactionsFn: typeof signAllTransactionsFn === 'function',
    hasSignAndSendTransactionFn: typeof signAndSendTransactionFn === 'function',
  })
  
  // Create Anchor-compatible wallet wrapper
  // Privy's signTransaction from useSignTransaction() hook expects:
  // { transaction: Uint8Array | Transaction, wallet: ConnectedStandardSolanaWallet }
  // and returns { signedTransaction: Uint8Array }
  const anchorWallet = {
    publicKey,
    signTransaction: async <T extends Transaction | VersionedTransaction>(tx: T): Promise<T> => {
      // Anchor primarily uses legacy Transaction objects, so we can safely cast
      if (!(tx instanceof Transaction)) {
        throw new Error('VersionedTransaction not supported with Privy wallet - Anchor uses legacy Transaction')
      }
      const legacyTx = tx as Transaction
      try {
        // Ensure transaction has required fields before signing
        if (!legacyTx.recentBlockhash) {
          throw new Error('Transaction missing recentBlockhash - this should be set by Anchor')
        }
        if (!legacyTx.feePayer) {
          legacyTx.feePayer = publicKey
        }
        
        // Serialize the transaction to Uint8Array before passing to Privy
        // Privy's signTransaction expects Uint8Array (its internal code calls bytes.slice())
        const serialized = legacyTx.serialize({
          requireAllSignatures: false,
          verifySignatures: false,
        })
        
        // Debug: show what we're sending to Privy
        console.log('[createWalletFromPrivyWallet] Sending to Privy:', {
          serializedLength: serialized.length,
          numSignaturesInSerialized: serialized[0], // First byte is num signatures
          feePayer: legacyTx.feePayer?.toString(),
          recentBlockhash: legacyTx.recentBlockhash,
          signaturesCount: legacyTx.signatures.length,
          signaturesPreSign: legacyTx.signatures.map(s => ({
            pubkey: s.publicKey?.toString(),
            hasSignature: !!s.signature,
          })),
        })
        
        // Call Privy's signTransaction hook function
        // It expects { transaction: Uint8Array, wallet: ConnectedStandardSolanaWallet, chain: string }
        // CRITICAL: Must specify chain to use devnet, otherwise Privy defaults to mainnet
        const result = await signTransactionFn({
          transaction: new Uint8Array(serialized),
          wallet: privyWallet,
          chain: 'solana:devnet', // Explicitly use devnet network
        })
        
        // Privy's signTransaction returns { signedTransaction: Uint8Array }
        const signedBytes = result.signedTransaction
        
        console.log('[createWalletFromPrivyWallet] signedBytes length:', signedBytes.length)
        
        // Deserialize the signed transaction back to a Transaction object
        const signedTx = Transaction.from(signedBytes)
        
        // Debug: verify the signed transaction
        console.log('[createWalletFromPrivyWallet] Signed transaction:', {
          feePayer: signedTx.feePayer?.toString(),
          recentBlockhash: signedTx.recentBlockhash,
          signaturesCount: signedTx.signatures.length,
          signatures: signedTx.signatures.map(s => ({
            pubkey: s.publicKey?.toString(),
            hasSignature: !!s.signature,
            signatureLength: s.signature?.length,
          })),
          instructionsCount: signedTx.instructions.length,
        })
        
        // CRITICAL: Verify the signature is attached to the fee payer
        const feePayerSig = signedTx.signatures.find(s => s.publicKey?.equals(signedTx.feePayer!))
        if (!feePayerSig || !feePayerSig.signature) {
          console.error('[createWalletFromPrivyWallet] ❌ Fee payer signature missing!')
        } else {
          console.log('[createWalletFromPrivyWallet] ✓ Fee payer signature present')
          
          // Verify the signature is cryptographically valid
          try {
            const isValid = signedTx.verifySignatures()
            console.log('[createWalletFromPrivyWallet] Signature verification:', isValid ? '✓ Valid' : '❌ Invalid')
            
            if (!isValid) {
              console.error('[createWalletFromPrivyWallet] ❌ Signature verification failed - signature does not match message!')
            }
          } catch (verifyError: any) {
            console.error('[createWalletFromPrivyWallet] ❌ Signature verification threw error:', verifyError.message)
          }
        }
        
        // CRITICAL: Verify the message hasn't changed
        // Compare the serialized message (without signatures) to detect any modifications
        const originalMessage = legacyTx.serializeMessage()
        const signedMessage = signedTx.serializeMessage()
        if (originalMessage.length !== signedMessage.length) {
          console.error('[createWalletFromPrivyWallet] ❌ Message length changed!', {
            originalLength: originalMessage.length,
            signedLength: signedMessage.length,
          })
        } else {
          let messageMatch = true
          for (let i = 0; i < originalMessage.length; i++) {
            if (originalMessage[i] !== signedMessage[i]) {
              console.error('[createWalletFromPrivyWallet] ❌ Message mismatch at byte', i)
              messageMatch = false
              break
            }
          }
          if (messageMatch) {
            console.log('[createWalletFromPrivyWallet] ✓ Message unchanged after signing')
          }
        }
        
        return signedTx as T
      } catch (error) {
        console.error('[createWalletFromPrivyWallet] Error signing transaction:', error)
        console.error('[createWalletFromPrivyWallet] Transaction details:', {
          recentBlockhash: legacyTx.recentBlockhash?.toString(),
          feePayer: legacyTx.feePayer?.toString(),
          instructions: legacyTx.instructions.length,
          signers: legacyTx.signatures.length,
        })
        throw error
      }
    },
    signAllTransactions: async <T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]> => {
      // Anchor primarily uses legacy Transaction objects
      // Type assertion needed because TypeScript can't narrow generic T
      const legacyTxs: Transaction[] = []
      for (const tx of txs) {
        if (tx instanceof Transaction) {
          legacyTxs.push(tx)
        } else {
          throw new Error('VersionedTransaction not supported with Privy wallet - Anchor uses legacy Transaction')
        }
      }
      
      try {
        // Use signAllTransactionsFn if provided
        if (signAllTransactionsFn && typeof signAllTransactionsFn === 'function') {
          // Serialize all transactions
          const serialized = legacyTxs.map(tx => 
            new Uint8Array(tx.serialize({
              requireAllSignatures: false,
              verifySignatures: false,
            }))
          )
          
          // Sign all transactions using Privy's signAllTransactions hook
          // CRITICAL: Must specify chain to use devnet, otherwise Privy defaults to mainnet
          const result = await signAllTransactionsFn({
            transactions: serialized,
            wallet: privyWallet,
            chain: 'solana:devnet', // Explicitly use devnet network
          })
          
          // Privy's signAllTransactions returns { signedTransactions: Uint8Array[] }
          const signedBytesArray = result.signedTransactions
          
          // Deserialize all signed transactions
          return signedBytesArray.map((bytes: Uint8Array) => 
            Transaction.from(bytes)
          ) as T[]
        }
        
        // Fallback: sign transactions sequentially using signTransaction
        // This is deterministic and preserves transaction order
        const signed: T[] = []
        for (const tx of legacyTxs) {
          const signedTx = await anchorWallet.signTransaction(tx)
          signed.push(signedTx as T)
        }
        return signed
      } catch (error) {
        console.error('[createWalletFromPrivyWallet] Error signing transactions:', error)
        throw error
      }
    },
    // Store the signAndSendTransaction function and privy wallet for direct usage
    signAndSendTransactionFn,
    privyWalletRef: privyWallet,
  } as PrivyWallet
  
  return anchorWallet
}
