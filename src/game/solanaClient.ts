import { Buffer } from 'buffer'
import { PublicKey, Connection, Transaction, VersionedTransaction, SystemProgram, TransactionInstruction } from '@solana/web3.js'
import { Program, AnchorProvider, Wallet, BN, Idl, utils } from '@coral-xyz/anchor'
// Import the natively generated IDL from Anchor build
// This IDL is automatically generated by 'anchor build' at target/idl/droog_game.json
// It includes proper discriminators and is the source of truth for the program interface
import DroogGameIDL from '../../target/idl/droog_game.json'
import { getCurrentMatchTime } from './timeUtils'
import { hashMatchIdStringToBytes, hashToU64 } from './matchIdHash'
import { createMatchIdentity, u64ToLE, assertBuffer } from './matchIdentity'
import { sortPlayerPubkeys } from './matchCoordination'

// Verify the IDL has discriminators (Anchor 0.32+ includes them automatically)
if (DroogGameIDL.instructions?.[0]?.discriminator) {
  console.log('[DroogGameClient] ✓ Using natively generated Anchor IDL with discriminators')
} else {
  console.warn('[DroogGameClient] ⚠️ IDL missing discriminators - this should not happen with Anchor 0.32+')
}

/**
 * Compute Anchor discriminator for an instruction or account.
 * Anchor uses SHA256("global:{name}") for instructions and SHA256("account:{name}") for accounts.
 * Returns the first 8 bytes as a Buffer.
 */
async function computeDiscriminator(prefix: 'global' | 'account', name: string): Promise<Buffer> {
  const encoder = new TextEncoder()
  const data = encoder.encode(`${prefix}:${name}`)
  const hashBuffer = await crypto.subtle.digest('SHA-256', data)
  const hash = Buffer.from(hashBuffer)
  // Return first 8 bytes
  return hash.subarray(0, 8)
}

/**
 * Deep clone function that preserves object structure and type references.
 * This is critical for IDL normalization - JSON.parse(JSON.stringify()) can
 * corrupt type references in arrays like ['CustomerState', 23].
 */
function deepCloneIdl(obj: any, visited = new WeakMap()): any {
  // Handle primitives and null
  if (obj === null || typeof obj !== 'object') {
    return obj
  }
  
  // Handle circular references
  if (visited.has(obj)) {
    return visited.get(obj)
  }
  
  // Handle Buffer (preserve as-is, don't clone)
  if (Buffer.isBuffer(obj)) {
    return obj
  }
  
  // Handle arrays
  if (Array.isArray(obj)) {
    const cloned: any[] = []
    visited.set(obj, cloned)
    for (let i = 0; i < obj.length; i++) {
      cloned[i] = deepCloneIdl(obj[i], visited)
    }
    return cloned
  }
  
  // Handle objects
  const cloned: any = {}
  visited.set(obj, cloned)
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      cloned[key] = deepCloneIdl(obj[key], visited)
    }
  }
  return cloned
}

/**
 * Normalize IDL by adding discriminators to instructions and accounts.
 * This is required because Anchor expects Buffer discriminators, not strings.
 * 
 * @param idl - The IDL object (may be missing discriminators)
 * @returns Normalized IDL with Buffer discriminators
 */
/**
 * Normalize option types to ensure they're in the format Anchor expects.
 * Anchor's type resolver can corrupt option types during resolution, so we
 * need to ensure they're in the correct format before passing to Anchor.
 */
function normalizeOptionTypes(idl: any): void {
  // Transform IDL types to match Anchor's TypeScript IdlType schema
  // Reference: ts/packages/anchor/src/idl.ts
  
  function normalizeType(type: any): any {
    if (!type || typeof type !== 'object') {
      // Handle string primitives
      if (type === 'publicKey' || type === 'pubKey') {
        return 'pubkey'  // Anchor expects lowercase "pubkey"
      }
      return type
    }
    
    // Handle option types: { option: IdlType }
    if ('option' in type) {
      let innerType = type.option
      
      // Recursively normalize the inner type
      if (typeof innerType === 'object' && innerType !== null) {
        return { option: normalizeType(innerType) }
      }
      
      // Convert publicKey/pubKey to pubkey
      if (innerType === 'publicKey' || innerType === 'pubKey') {
        innerType = 'pubkey'
      }
      
      return { option: innerType }
    }
    
    // Handle defined types: must be { defined: { name: string } }
    if ('defined' in type) {
      const definedValue = type.defined
      
      // If it's a string, wrap it in the correct structure
      if (typeof definedValue === 'string') {
        return { defined: { name: definedValue } }
      }
      
      // If it's already an object, ensure it has the name property
      if (typeof definedValue === 'object' && definedValue !== null) {
        return { defined: definedValue }
      }
    }
    
    // Handle array types: { array: [IdlType, size] }
    if ('array' in type && Array.isArray(type.array)) {
      const [innerType, size] = type.array
      return { array: [normalizeType(innerType), size] }
    }
    
    // Handle vec types
    if ('vec' in type) {
      return { vec: normalizeType(type.vec) }
    }
    
    return type
  }
  
  function normalizeFields(fields: any[]): void {
    if (!Array.isArray(fields)) return
    
    fields.forEach(field => {
      if (field.type) {
        field.type = normalizeType(field.type)
      }
    })
  }
  
  // Normalize accounts
  if (idl.accounts) {
    idl.accounts.forEach((account: any) => {
      // Handle both formats: with kind: 'struct' and without
      if (account.type?.fields) {
        normalizeFields(account.type.fields)
      }
    })
  }
  
  // Normalize types
  if (idl.types) {
    idl.types.forEach((type: any) => {
      // Handle both formats: with kind: 'struct' and without
      if (type.type?.fields) {
        normalizeFields(type.type.fields)
      }
      if (type.type?.kind === 'enum' && type.type.variants) {
        type.type.variants.forEach((variant: any) => {
          if (variant.fields) {
            normalizeFields(variant.fields)
          }
        })
      }
    })
  }
  
  // Normalize instructions
  if (idl.instructions) {
    idl.instructions.forEach((ix: any) => {
      if (ix.args) {
        normalizeFields(ix.args)
      }
    })
  }
  
  // Normalize events
  if (idl.events) {
    idl.events.forEach((event: any) => {
      if (event.fields) {
        normalizeFields(event.fields)
      }
    })
  }
}

async function normalizeIdl(idl: any): Promise<any> {
  // CRITICAL: After fixing the IDL array format to use { defined: 'TypeName' },
  // we can now safely add discriminators. The key is to preserve all object
  // references, especially for the types array which Anchor uses for resolution.
  //
  // Strategy: Only modify instruction/account objects that need discriminators,
  // and preserve everything else as original references.
  
  // FIRST: Normalize option types to ensure they're in the correct format
  // This must happen before adding discriminators
  normalizeOptionTypes(idl)
  
  // Check if discriminators are already present
  const needsNormalization = 
    (idl.instructions?.some((inst: any) => !inst.discriminator || !Buffer.isBuffer(inst.discriminator))) ||
    (idl.accounts?.some((acc: any) => !acc.discriminator || !Buffer.isBuffer(acc.discriminator)))
  
  if (!needsNormalization) {
    // IDL already has discriminators, return as-is (but option types are normalized)
    return idl
  }
  
  // Create minimal copy - preserve all references except where we add discriminators
  const normalized: any = {
    ...idl,
    // Preserve original arrays - we'll only modify individual items
    instructions: idl.instructions,
    accounts: idl.accounts,
    types: idl.types, // CRITICAL: Keep exact same reference
    events: idl.events,
    errors: idl.errors,
  }
  
  // Add discriminators only where missing, modifying items in place
  // CRITICAL: Modify objects in-place to preserve all nested type references
  // Using spread operator creates new objects which breaks Anchor's type resolution
  if (normalized.instructions && Array.isArray(normalized.instructions)) {
    for (let i = 0; i < normalized.instructions.length; i++) {
      const inst = normalized.instructions[i]
      if (!inst.discriminator || !Buffer.isBuffer(inst.discriminator)) {
        // Add discriminator in-place to preserve all nested references
        inst.discriminator = await computeDiscriminator('global', inst.name)
      }
    }
  }
  
  if (normalized.accounts && Array.isArray(normalized.accounts)) {
    for (let i = 0; i < normalized.accounts.length; i++) {
      const acc = normalized.accounts[i]
      if (!acc.discriminator || !Buffer.isBuffer(acc.discriminator)) {
        // Add discriminator in-place to preserve all nested type references
        // This ensures Anchor's type resolver can find types like { defined: 'CustomerState' }
        acc.discriminator = await computeDiscriminator('account', acc.name)
      }
    }
  }
  
  // Types array must remain the exact same reference - Anchor uses it for type resolution
  // Do NOT modify or clone it
  
  return normalized
}

// Program ID - matches the deployed program on devnet
export const PROGRAM_ID = new PublicKey('H5zERNABU2sbbPPaCzYdVabNmAzSWm9eX8PJr2fekncB')

export interface MatchState {
  matchId: BN
  startTs: BN
  endTs: BN
  playerA: PublicKey
  playerB: PublicKey
  customers: CustomerState[]
  playerASales: number
  playerBSales: number
  playerAReputation: number
  playerBReputation: number
  isFinalized: boolean
}

export interface CustomerState {
  layer: number
  lastServedTs: BN
  totalServes: number
  lastServedBy: PublicKey | null
}

// PlantState enum from Anchor program
export type PlantState = 
  | { __kind: 'Empty' }
  | { __kind: 'Growing'; strainLevel: number; plantedAt: BN }
  | { __kind: 'Ready'; strainLevel: number }

export interface GrowSlot {
  // New structure (from chain)
  plantState: PlantState
  strainLevel: number
  variantId: number
  lastHarvestedTs: BN
  
  // Legacy fields (computed for backward compatibility)
  occupied: boolean
  plantedTs: BN
  readyTs: BN
  harvested: boolean
}

export interface Inventory {
  level1: number
  level2: number
  level3: number
}

export interface GrowState {
  matchId: BN
  playerA: PublicKey
  playerB: PublicKey
  playerASlots: GrowSlot[]
  playerBSlots: GrowSlot[]
  playerAInventory: Inventory
  playerBInventory: Inventory
}

export interface DeliveryState {
  matchId: BN
  lastUpdateTs: BN
  availableCustomers: number[]
  activeCount: number
}

// Growth times in seconds (matching on-chain constants)
export const GROWTH_TIMES = {
  1: 180,  // Level 1: 3 minutes
  2: 360,  // Level 2: 6 minutes
  3: 600,  // Level 3: 10 minutes
} as const

// Smell rates per minute
export const SMELL_RATES = {
  1: 1,  // Level 1: +1 per minute
  2: 2,  // Level 2: +2 per minute
  3: 4,  // Level 3: +4 per minute
} as const

// Endgame lock: no planting in final 5 minutes
export const ENDGAME_LOCK_SECONDS = 300

// Number of grow slots per player
export const SLOTS_PER_PLAYER = 6

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AnyProgram = Program<any>

// Cached normalized IDL promise (computed once, reused for all instances)
let normalizedIdlPromise: Promise<any> | null = null

/**
 * Get or create the normalized IDL with discriminators.
 * This is cached so subsequent calls return the same promise.
 * 
 * CRITICAL: Anchor's type resolver requires exact object structure.
 * The issue is that when Anchor processes option types, it expects { option: 'publicKey' }
 * but might be receiving just 'publicKey' if the structure is corrupted.
 */
function getNormalizedIdl(): Promise<any> {
  if (!normalizedIdlPromise) {
    // Native Anchor 0.32+ IDL has discriminators as arrays, not Buffers
    // Check if discriminators are present (either as arrays or Buffers)
    const firstInstruction = DroogGameIDL.instructions?.[0] as any
    const hasDiscriminators = 
      firstInstruction?.discriminator && 
      (Array.isArray(firstInstruction.discriminator) || Buffer.isBuffer(firstInstruction.discriminator))
    
    if (hasDiscriminators) {
      // Native Anchor IDL - convert array discriminators to Buffers if needed
      // Anchor's Program class can handle both formats, but we normalize to Buffers for consistency
      const idl = deepCloneIdl(DroogGameIDL)
      
      // Ensure the IDL address matches the actual program ID
      idl.address = PROGRAM_ID.toString()
      
      // Convert array discriminators to Buffers for instructions
      if (idl.instructions) {
        for (const inst of idl.instructions) {
          if (inst.discriminator && Array.isArray(inst.discriminator) && !Buffer.isBuffer(inst.discriminator)) {
            inst.discriminator = Buffer.from(inst.discriminator)
          }
        }
      }
      
      // Convert array discriminators to Buffers for accounts
      if (idl.accounts) {
        for (const acc of idl.accounts) {
          if (acc.discriminator && Array.isArray(acc.discriminator) && !Buffer.isBuffer(acc.discriminator)) {
            acc.discriminator = Buffer.from(acc.discriminator)
          }
        }
      }
      
      normalizedIdlPromise = Promise.resolve(idl)
    } else {
      // IDL missing discriminators - this shouldn't happen with native Anchor IDL
      console.warn('[DroogGameClient] IDL missing discriminators, attempting normalization...')
      
      // Need to add discriminators. Use deepCloneIdl which preserves structure
      const cloned = deepCloneIdl(DroogGameIDL)
      // Ensure the IDL address matches the actual program ID
      cloned.address = PROGRAM_ID.toString()
      normalizedIdlPromise = normalizeIdl(cloned)
    }
  }
  return normalizedIdlPromise
}

export class DroogGameClient {
  private program: AnyProgram
  private connection: Connection
  private provider: AnchorProvider

  /**
   * Private constructor - use DroogGameClient.create() instead.
   */
  private constructor(connection: Connection, wallet: Wallet, normalizedIdl: any) {
    // Validate wallet structure before creating provider
    if (!wallet.publicKey) {
      throw new Error('Wallet must have publicKey property')
    }
    if (!(wallet.publicKey instanceof PublicKey)) {
      throw new Error(`Wallet publicKey must be a PublicKey instance, got ${typeof wallet.publicKey}`)
    }
    if (typeof wallet.signTransaction !== 'function') {
      throw new Error('Wallet must have signTransaction method')
    }
    if (typeof wallet.signAllTransactions !== 'function') {
      throw new Error('Wallet must have signAllTransactions method')
    }

    // Debug logging (can be removed in production)
    console.log('[DroogGameClient] Creating client with:', {
      publicKey: wallet.publicKey.toString(),
      hasSignTransaction: typeof wallet.signTransaction === 'function',
      hasSignAllTransactions: typeof wallet.signAllTransactions === 'function',
      publicKeyIsPublicKey: wallet.publicKey instanceof PublicKey,
    })

    this.connection = connection
    this.provider = new AnchorProvider(connection, wallet, {
      commitment: 'confirmed',
    })
    
    // Validate normalized IDL has Buffer discriminators
    if (normalizedIdl.instructions?.[0]?.discriminator) {
      const firstDiscriminator = normalizedIdl.instructions[0].discriminator
      if (!Buffer.isBuffer(firstDiscriminator)) {
        throw new Error(
          `IDL discriminator is not a Buffer. Got type: ${typeof firstDiscriminator}. ` +
          'IDL normalization failed. This is a bug.'
        )
      }
    }
    
    // Debug: Log IDL structure before creating Program
    console.log('[DroogGameClient] IDL accounts array:', normalizedIdl.accounts?.map((acc: any) => acc.name))
    console.log('[DroogGameClient] IDL types array:', normalizedIdl.types?.map((t: any) => t.name))
    
    // Log MatchState account structure to see how array types are represented
    const matchStateAccount = normalizedIdl.accounts?.find((acc: any) => acc.name === 'MatchState')
    if (matchStateAccount) {
      const customersField = matchStateAccount.type?.fields?.find((f: any) => f.name === 'customers')
      if (customersField) {
        console.log('[DroogGameClient] MatchState.customers field type:', JSON.stringify(customersField.type, null, 2))
        console.log('[DroogGameClient] customers field type structure:', {
          isArray: customersField.type && typeof customersField.type === 'object' && 'array' in customersField.type,
          arrayValue: customersField.type?.array,
          arrayType: typeof customersField.type?.array?.[0],
        })
      }
    }
    
    // Log CustomerState type structure to debug option type issue
    // Debug: Log IDL structure before creating Program (for troubleshooting)
    const customerStateType = normalizedIdl.types?.find((t: any) => t.name === 'CustomerState')
    if (customerStateType) {
      const lastServedByField = customerStateType.type?.fields?.find((f: any) => f.name === 'lastServedBy')
      if (lastServedByField) {
        console.log('[DroogGameClient] lastServedBy field type:', lastServedByField.type)
        console.log('[DroogGameClient] lastServedBy.type.option:', lastServedByField.type?.option)
      }
    }
    
    if (normalizedIdl.instructions?.[0]?.accounts) {
      console.log('[DroogGameClient] First instruction accounts:', normalizedIdl.instructions[0].accounts.map((acc: any) => ({
        name: acc.name,
        type: acc.type,
        isMut: acc.isMut,
        isSigner: acc.isSigner,
      })))
    }
    
    // Use the normalized IDL directly
    // The normalizeIdl function already handles option types correctly
    // and adds Buffer discriminators, so we don't need the JSON round-trip
    try {
      // Try creating Program with the IDL as-is first
      // Anchor should be able to handle IDLs without discriminators (it computes them)
      // But if normalization added discriminators, use those
      
      // Create a clean copy to avoid mutating the original
      // Use deepCloneIdl to preserve Buffer discriminators (JSON.parse/stringify breaks Buffers)
      const idlForProgram = deepCloneIdl(normalizedIdl)
      
      // Temporarily remove events to avoid initialization errors
      // Events are not needed for basic program functionality and can be parsed from logs
      const originalEvents = idlForProgram.events
      delete idlForProgram.events
      
      // Ensure the IDL address matches the actual program ID
      // This is critical to avoid DeclaredProgramIdMismatch errors
      if (idlForProgram.address !== PROGRAM_ID.toString()) {
        console.warn('[DroogGameClient] IDL address mismatch, updating:', {
          idlAddress: idlForProgram.address,
          expectedAddress: PROGRAM_ID.toString(),
        })
        idlForProgram.address = PROGRAM_ID.toString()
      }
      
      // Debug: Log the IDL structure before creating Program
      console.log('[DroogGameClient] Creating Program with IDL:', {
        idlAddress: idlForProgram.address,
        programId: PROGRAM_ID.toString(),
        instructions: idlForProgram.instructions?.length,
        accounts: idlForProgram.accounts?.length,
        types: idlForProgram.types?.length,
        firstInstruction: idlForProgram.instructions?.[0] ? {
          name: idlForProgram.instructions[0].name,
          hasDiscriminator: !!idlForProgram.instructions[0].discriminator,
        } : null,
      })
      
      // Create Program - Anchor 0.30+ uses the IDL's address field as the program ID
      // We've ensured the address matches PROGRAM_ID above
      // Double-check the IDL address before creating Program
      if (idlForProgram.address !== PROGRAM_ID.toString()) {
        console.error('[DroogGameClient] CRITICAL: IDL address mismatch before Program creation:', {
          idlAddress: idlForProgram.address,
          expectedAddress: PROGRAM_ID.toString(),
        })
        idlForProgram.address = PROGRAM_ID.toString()
      }
      
      this.program = new Program(idlForProgram as any, this.provider)
      
      // Restore events after successful initialization
      // Anchor will still be able to parse events from transaction logs
      if (originalEvents && this.program.idl) {
        this.program.idl.events = originalEvents
      }
      
      // Debug: Verify the program was created correctly
      console.log('[DroogGameClient] Program created successfully:', {
        programId: this.program.programId.toString(),
        expectedProgramId: PROGRAM_ID.toString(),
        idlAddress: this.program.idl?.address,
        idlInstructions: this.program.idl?.instructions?.length,
        methodsAvailable: Object.keys(this.program.methods || {}).length,
        hasInitMatch: !!(this.program.methods as any)?.initMatch,
        programIdsMatch: this.program.programId.toString() === PROGRAM_ID.toString(),
      })
      
      // Verify program ID matches
      if (this.program.programId.toString() !== PROGRAM_ID.toString()) {
        console.error('[DroogGameClient] CRITICAL: Program ID mismatch after creation:', {
          programId: this.program.programId.toString(),
          expectedProgramId: PROGRAM_ID.toString(),
          idlAddress: this.program.idl?.address,
        })
        throw new Error(
          `Program ID mismatch: Program has ${this.program.programId.toString()}, expected ${PROGRAM_ID.toString()}. ` +
          `IDL address: ${this.program.idl?.address}. ` +
          `This indicates a DeclaredProgramIdMismatch will occur. ` +
          `Please ensure the program's declare_id! matches the deployed program ID.`
        )
      }
    } catch (error) {
      console.error('[DroogGameClient] Error creating Program:', error)
      console.error('[DroogGameClient] IDL type:', typeof normalizedIdl)
      console.error('[DroogGameClient] Provider wallet:', {
        publicKey: this.provider.wallet.publicKey?.toString(),
        hasSignTransaction: typeof this.provider.wallet.signTransaction === 'function',
      })
      // Log IDL structure for debugging
      console.error('[DroogGameClient] IDL accounts:', normalizedIdl.accounts?.map((acc: any) => acc.name))
      console.error('[DroogGameClient] IDL types:', normalizedIdl.types?.map((t: any) => t.name))
      if (normalizedIdl.instructions?.[0]?.accounts) {
        console.error('[DroogGameClient] First instruction accounts:', normalizedIdl.instructions[0].accounts.map((acc: any) => ({
          name: acc.name,
          type: acc.type,
        })))
      }
      // Log discriminator info for debugging
      if (normalizedIdl.instructions?.[0]) {
        console.error('[DroogGameClient] First instruction discriminator:', {
          name: normalizedIdl.instructions[0].name,
          type: typeof normalizedIdl.instructions[0].discriminator,
          isBuffer: Buffer.isBuffer(normalizedIdl.instructions[0].discriminator),
          value: normalizedIdl.instructions[0].discriminator,
        })
      }
      throw error
    }
  }

  /**
   * Fetch IDL from the chain for the deployed program.
   * This is useful when the local IDL might be out of sync.
   * 
   * @param connection - Solana connection
   * @param programId - Program public key
   * @returns Promise resolving to IDL or null if not found
   */
  static async fetchIdlFromChain(connection: Connection, programId: PublicKey): Promise<Idl | null> {
    try {
      // Note: Anchor's IDL derivation can vary by version
      // The IDL was deployed to: HTSsZsh85GJVoqACDqeAnpwHq2CCnSGuxdXgP81xwmJ6
      // Try the known deployed address first
      const knownIdlAddress = new PublicKey('HTSsZsh85GJVoqACDqeAnpwHq2CCnSGuxdXgP81xwmJ6')
      let accountInfo = await connection.getAccountInfo(knownIdlAddress)
      
      if (accountInfo) {
        // Anchor stores IDL in a binary format, not raw JSON
        // Use Anchor's IDL decoder to properly deserialize it
        try {
          // Anchor's IDL account structure:
          // - 8 bytes: account discriminator
          // - Remaining: compressed/encoded IDL data
          const idlData = accountInfo.data.slice(8)
          
          // Try to decode using Anchor's IDL decoder
          // The IDL is stored in a specific binary format that needs proper deserialization
          // For now, we'll skip the on-chain IDL fetch since it requires Anchor's internal decoders
          // The static IDL from target/idl/droog_game.json is the source of truth anyway
          console.log('[DroogGameClient] IDL found on-chain but decoding requires Anchor internals')
          console.log('[DroogGameClient] Using static IDL instead (this is the recommended approach)')
          return null
        } catch (parseError) {
          console.warn('[DroogGameClient] Failed to decode IDL data:', parseError)
        }
      }
      
      // Fallback: Try standard Anchor derivation (may not work for all Anchor versions)
      const [idlAddress] = PublicKey.findProgramAddressSync(
        [Buffer.from('anchor'), Buffer.from('idl'), programId.toBuffer()],
        programId
      )
      
      accountInfo = await connection.getAccountInfo(idlAddress)
      if (accountInfo) {
        // Same issue - IDL is in binary format, not JSON
        console.log('[DroogGameClient] IDL found at standard address but requires binary decoding')
        console.log('[DroogGameClient] Using static IDL instead')
        return null
      }
      
      // IDL not found - this is OK, we'll use the static IDL
      console.log('[DroogGameClient] IDL not found on-chain, using static IDL (this is normal)')
      return null
    } catch (error) {
      console.warn('[DroogGameClient] Failed to fetch IDL from chain:', error)
      return null
    }
  }

  /**
   * Static factory method to create a DroogGameClient.
   * This normalizes the IDL (adds discriminators) before creating the Program.
   * If the static IDL fails, it will attempt to fetch the IDL from the chain.
   * 
   * @param connection - Solana connection
   * @param wallet - Anchor-compatible wallet
   * @returns Promise resolving to DroogGameClient instance
   */
  static async create(connection: Connection, wallet: Wallet): Promise<DroogGameClient> {
    // CRITICAL: Always try to fetch IDL from chain first to ensure we have the latest version
    // This is especially important after program upgrades
    console.log('[DroogGameClient] Attempting to fetch IDL from chain to ensure latest version...')
    const chainIdl = await this.fetchIdlFromChain(connection, PROGRAM_ID)
    
    let normalizedIdl: any
    if (chainIdl) {
      // Use on-chain IDL (most up-to-date)
      const cloned = deepCloneIdl(chainIdl)
      cloned.address = PROGRAM_ID.toString()
      normalizedIdl = await normalizeIdl(cloned)
      console.log('[DroogGameClient] ✓ Using IDL fetched from chain (latest version)')
      
      // Verify player_b is not a signer in the on-chain IDL
      const initMatchIx = normalizedIdl.instructions?.find((ix: any) => ix.name === 'initMatch')
      if (initMatchIx) {
        const playerBAccount = initMatchIx.accounts?.find((acc: any) => acc.name === 'playerB' || acc.name === 'player_b')
        if (playerBAccount) {
          console.log('[DroogGameClient] On-chain IDL player_b account:', {
            name: playerBAccount.name,
            isSigner: playerBAccount.signer,
            hasSignerField: 'signer' in playerBAccount,
          })
          if (playerBAccount.signer === true) {
            console.error('[DroogGameClient] ⚠️ WARNING: On-chain IDL shows player_b as signer! This indicates the deployed program is incorrect.')
          }
        }
      }
    } else {
      // Fallback to static IDL if chain fetch fails
      console.warn('[DroogGameClient] Failed to fetch IDL from chain, using static IDL...')
      normalizedIdl = await getNormalizedIdl()
    }
    
    // Try to create the client
    try {
      return new DroogGameClient(connection, wallet, normalizedIdl)
    } catch (error: any) {
      // If we get an InstructionFallbackNotFound error, try with static IDL
      const errorMessage = error?.message || error?.toString() || ''
      if (errorMessage.includes('InstructionFallbackNotFound') || errorMessage.includes('101')) {
        console.warn('[DroogGameClient] Chain IDL failed, trying static IDL...')
        normalizedIdl = await getNormalizedIdl()
        return new DroogGameClient(connection, wallet, normalizedIdl)
      }
      // Re-throw if it's a different error
      throw error
    }
  }

  /**
   * Derive Match PDA using hash-based seeds with player pubkeys.
   * This is the new deterministic approach that prevents collisions.
   * 
   * @param matchIdHash - 32-byte SHA-256 hash of the matchId string (must be Buffer)
   * @param playerA - First player's public key (will be sorted deterministically)
   * @param playerB - Second player's public key (will be sorted deterministically)
   * @returns [PDA public key, bump seed]
   */
  static deriveMatchPDAFromHash(
    matchIdHash: Buffer,
    playerA: PublicKey,
    playerB: PublicKey
  ): [PublicKey, number] {
    // Verify hash is a Buffer
    assertBuffer(matchIdHash, 'matchIdHash')
    
    // Sort pubkeys deterministically for consistent PDA derivation
    // Use the same sorting function as initMatch to ensure consistency
    const [first, second] = sortPlayerPubkeys(playerA, playerB)
    
    // Ensure all seeds are Buffers
    const firstBuffer = first.toBuffer()
    const secondBuffer = second.toBuffer()
    assertBuffer(firstBuffer, 'first player pubkey buffer')
    assertBuffer(secondBuffer, 'second player pubkey buffer')
    
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from('match'),
        matchIdHash,
        firstBuffer,
        secondBuffer
      ],
      PROGRAM_ID
    )
  }

  /**
   * Derive Match PDA (legacy method for backward compatibility).
   * @deprecated Use deriveMatchPDAFromHash() for new matches.
   */
  static deriveMatchPDA(matchId: number | BN): [PublicKey, number] {
    const matchIdBN = typeof matchId === 'number' ? new BN(matchId) : matchId
    return PublicKey.findProgramAddressSync(
      [Buffer.from('match'), matchIdBN.toArrayLike(Buffer, 'le', 8)],
      PROGRAM_ID
    )
  }

  /**
   * Derive Grow State PDA
   * Seeds: ["grow", match_id.to_le_bytes()]
   */
  static deriveGrowStatePDA(matchId: number | BN | bigint): [PublicKey, number] {
    const matchIdLE = u64ToLE(matchId)
    assertBuffer(matchIdLE, 'matchIdLE for grow PDA')
    return PublicKey.findProgramAddressSync(
      [Buffer.from('grow'), matchIdLE],
      PROGRAM_ID
    )
  }

  /**
   * Derive Delivery State PDA
   * Seeds: ["delivery", match_id.to_le_bytes()]
   */
  static deriveDeliveryStatePDA(matchId: number | BN | bigint): [PublicKey, number] {
    const matchIdLE = u64ToLE(matchId)
    assertBuffer(matchIdLE, 'matchIdLE for delivery PDA')
    return PublicKey.findProgramAddressSync(
      [Buffer.from('delivery'), matchIdLE],
      PROGRAM_ID
    )
  }

  /**
   * Initialize a new match on-chain using hash-based PDA seeds.
   * 
   * @param matchIdString - The string matchId (e.g., "match_1234567890_abc123")
   * @param startTs - Match start timestamp (Unix seconds)
   * @param playerA - First player's public key (must be < playerB for determinism)
   * @param playerB - Second player's public key (must be > playerA for determinism)
   * @returns Transaction signature
   */
  async initMatch(
    matchIdString: string,
    startTs: number,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    // Ensure deterministic ordering: playerA < playerB
    // Use the same sorting function as MatchStartModal to ensure consistency
    // This matches Rust's Pubkey comparison (lexicographic byte-by-byte)
    const [sortedA, sortedB] = sortPlayerPubkeys(playerA, playerB)
    
    // Validate the sorting is correct (sortedA must be < sortedB)
    const aBytes = sortedA.toBytes()
    const bBytes = sortedB.toBytes()
    for (let i = 0; i < aBytes.length; i++) {
      if (aBytes[i] > bBytes[i]) {
        throw new Error(
          `Invalid player order: sortedA (${sortedA.toString()}) > sortedB (${sortedB.toString()}) at byte ${i}. ` +
          `This indicates a bug in sortPlayerPubkeys.`
        )
      }
      if (aBytes[i] < bBytes[i]) {
        break // Order is correct
      }
    }

    // Create canonical match identity (normalizes all representations)
    const matchIdentity = await createMatchIdentity(matchIdString)
    
    // Verify all buffers are correct
    assertBuffer(matchIdentity.hash32, 'matchIdentity.hash32')
    assertBuffer(matchIdentity.u64le, 'matchIdentity.u64le')

    // Derive PDA using hash-based seeds (we'll verify this matches Anchor's derivation)
    let [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      sortedA,
      sortedB
    )

    // Convert hash to array for Anchor instruction (Anchor expects array, not Buffer)
    const matchIdHashArray = Array.from(matchIdentity.hash32)
    
    // Convert u64 bigint to BN for Anchor
    // For Option<u64>, pass the BN directly (Anchor handles Some/None wrapping)
    const matchIdU64BN = matchIdentity.u64

    // Debug: Log the instruction args to verify types
    console.log('[DroogGameClient.initMatch] Calling with args:', {
      matchIdHashArray: matchIdHashArray.length,
      matchIdU64BN: matchIdU64BN.toString(),
      startTs: startTs,
    })

    // Verify the instruction exists in the IDL
    const idl = this.program.idl
    if (!idl || !idl.instructions) {
      throw new Error('Program IDL is missing or invalid')
    }
    
    const initMatchIx = idl.instructions.find((ix: any) => ix.name === 'initMatch')
    if (!initMatchIx) {
      console.error('[DroogGameClient.initMatch] Available instructions:', idl.instructions.map((ix: any) => ix.name))
      throw new Error(
        'initMatch instruction not found in program IDL. ' +
        'Available instructions: ' + idl.instructions.map((ix: any) => ix.name).join(', ')
      )
    }

    // Debug: Log instruction structure
    console.log('[DroogGameClient.initMatch] Instruction found:', {
      name: initMatchIx.name,
      hasDiscriminator: !!initMatchIx.discriminator,
      discriminator: initMatchIx.discriminator ? Array.from(initMatchIx.discriminator) : null,
      discriminatorType: typeof initMatchIx.discriminator,
      isBuffer: Buffer.isBuffer(initMatchIx.discriminator),
      args: initMatchIx.args?.map((arg: any) => ({
        name: arg.name,
        type: JSON.stringify(arg.type),
      })),
    })

    // Verify discriminator is a Buffer (required by Anchor)
    if (!initMatchIx.discriminator || !Buffer.isBuffer(initMatchIx.discriminator)) {
      console.warn('[DroogGameClient.initMatch] Missing or invalid discriminator, computing...')
      // Compute discriminator if missing
      const encoder = new TextEncoder()
      const data = encoder.encode(`global:${initMatchIx.name}`)
      const hashBuffer = await crypto.subtle.digest('SHA-256', data)
      const hash = Buffer.from(hashBuffer)
      initMatchIx.discriminator = hash.subarray(0, 8)
      console.log('[DroogGameClient.initMatch] Computed discriminator:', Array.from(initMatchIx.discriminator))
    }

    // Use type assertion to avoid TypeScript deep instantiation error
    const methods = this.program.methods as any
    
    // Debug: Log what methods are available
    console.log('[DroogGameClient.initMatch] Available methods:', Object.keys(methods))
    console.log('[DroogGameClient.initMatch] Program IDL instructions:', this.program.idl?.instructions?.map((ix: any) => ix.name))
    
    // Detailed instruction debugging
    console.log('[DroogGameClient.initMatch] Available instructions with discriminators:', 
      this.program.idl?.instructions?.map((ix: any) => ({
        name: ix.name,
        discriminator: ix.discriminator ? Array.from(ix.discriminator) : 'missing',
        discriminatorType: typeof ix.discriminator,
        isBuffer: Buffer.isBuffer(ix.discriminator),
      }))
    )
    
    console.log('[DroogGameClient.initMatch] Looking for instruction: initMatch')
    
    // Check if the instruction exists
    const ixDef = this.program.idl?.instructions?.find((ix: any) => ix.name === 'initMatch')
    console.log('[DroogGameClient.initMatch] Found instruction definition:', ixDef ? {
      name: ixDef.name,
      discriminator: ixDef.discriminator ? Array.from(ixDef.discriminator) : 'missing',
      args: ixDef.args?.map((arg: any) => ({ name: arg.name, type: JSON.stringify(arg.type) })),
    } : 'NOT FOUND')
    
    // Also check for snake_case version
    const ixDefSnake = this.program.idl?.instructions?.find((ix: any) => ix.name === 'init_match')
    if (ixDefSnake) {
      console.warn('[DroogGameClient.initMatch] Found init_match (snake_case) but looking for initMatch (camelCase)')
    }
    
    // Debug: Check if method exists
    if (!methods.initMatch) {
      console.error('[DroogGameClient.initMatch] Method initMatch not found in program.methods')
      console.error('[DroogGameClient.initMatch] Program object keys:', Object.keys(this.program))
      console.error('[DroogGameClient.initMatch] Program.methods type:', typeof methods)
      
      // Try to manually construct using the coder
      console.warn('[DroogGameClient.initMatch] Attempting manual instruction construction...')
      try {
        const discriminator = initMatchIx.discriminator
        if (!discriminator || !Buffer.isBuffer(discriminator)) {
          throw new Error('Discriminator is missing or invalid')
        }
        
        // Encode the instruction data manually
        const coder = this.program.coder
        // For Option<u64>, Anchor expects { some: value } or null
        // But when encoding, we can pass the value directly and Anchor handles it
        const args = {
          matchIdHash: matchIdHashArray,
          matchId: matchIdU64BN, // Option<u64> - Anchor will wrap this as Some(value)
          startTs: new BN(startTs),
        }
        
        // Encode instruction data using the instruction name
        // The coder will use the discriminator from the IDL
        const data = coder.instruction.encode(initMatchIx.name, args)
        
        // Create instruction
        // Note: player_b (sortedB) is NOT a signer - only player_a (sortedA) signs
        // The Rust program uses UncheckedAccount for player_b
        const instruction = new TransactionInstruction({
          programId: this.program.programId,
          keys: [
            { pubkey: matchPDA, isSigner: false, isWritable: true },
            { pubkey: sortedA, isSigner: true, isWritable: true },
            { pubkey: sortedB, isSigner: false, isWritable: false }, // Not a signer
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
          ],
          data,
        })
        
        const tx = new Transaction().add(instruction)
        const signature = await this.provider.sendAndConfirm(tx)
        return signature
      } catch (manualError) {
        console.error('[DroogGameClient.initMatch] Manual construction failed:', manualError)
        throw new Error('initMatch method not found and manual construction failed: ' + (manualError as Error).message)
      }
    }
    
    try {
      // CRITICAL: Try to get Anchor to derive the PDA by building the instruction
      // without passing matchState, then extract what PDA it derived
      let anchorDerivedPDA: PublicKey | null = null
      
      try {
        // Build instruction without matchState to see what Anchor derives
        const testInstruction = await methods
          .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
          .accounts({
            playerA: sortedA,
            playerB: sortedB,
            systemProgram: SystemProgram.programId,
          })
          .instruction()
        
        // Extract the PDA from the instruction's account keys
        // The first account should be the matchState PDA
        if (testInstruction.keys && testInstruction.keys.length > 0) {
          const extractedPDA = testInstruction.keys[0].pubkey
          anchorDerivedPDA = extractedPDA
          console.log('[DroogGameClient.initMatch] Extracted PDA from Anchor instruction:', extractedPDA.toString())
        }
      } catch (e) {
        console.warn('[DroogGameClient.initMatch] Could not extract PDA from instruction:', e)
      }
      
      // Also manually verify our derivation
      const manualSeeds = [
        Buffer.from('match'),
        matchIdentity.hash32,
        sortedA.toBuffer(),
        sortedB.toBuffer()
      ]
      const [manualPDA, manualBump] = PublicKey.findProgramAddressSync(
        manualSeeds,
        PROGRAM_ID
      )
      
      // Use Anchor's derived PDA if we got it, otherwise use our manual derivation
      const finalPDA = anchorDerivedPDA ?? matchPDA
      
      // Log right before calling the method
      console.log('[DroogGameClient.initMatch] PDA Derivation Check:', {
        ourPDA: matchPDA.toString(),
        anchorDerivedPDA: anchorDerivedPDA ? anchorDerivedPDA.toString() : 'NOT EXTRACTED',
        manualPDA: manualPDA.toString(),
        finalPDA: finalPDA.toString(),
        match: matchPDA.equals(finalPDA) ? '✓ MATCH' : '✗ MISMATCH',
        manualMatch: manualPDA.equals(finalPDA) ? '✓ MATCH' : '✗ MISMATCH',
        bump: manualBump,
        seeds: {
          match: Buffer.from('match').toString('hex'),
          hash: matchIdentity.hash32.toString('hex'),
          hashArray: matchIdHashArray.slice(0, 8).join(','), // First 8 bytes
          playerA: sortedA.toString(),
          playerB: sortedB.toString(),
          playerABytes: sortedA.toBuffer().toString('hex'),
          playerBBytes: sortedB.toBuffer().toString('hex'),
        },
        matchIdHashArrayLength: matchIdHashArray.length,
        matchIdU64BN: matchIdU64BN.toString(),
        startTs: startTs,
      })
      
      // Update matchPDA to use the final PDA
      if (!matchPDA.equals(finalPDA)) {
        console.warn('[DroogGameClient.initMatch] Using different PDA than our initial derivation')
        matchPDA = finalPDA
      }
      
      // Let Anchor derive the PDA automatically using the instruction args
      // The IDL specifies that match_id_hash comes from instruction args, so Anchor should derive it correctly
      console.log('[DroogGameClient.initMatch] Letting Anchor auto-derive PDA from instruction args...')
      console.log('[DroogGameClient.initMatch] PDA derivation details:', {
        ourDerivedPDA: matchPDA.toString(),
        manualPDA: manualPDA.toString(),
        match: matchPDA.equals(manualPDA),
        seeds: {
          match: Buffer.from('match').toString('hex'),
          hashLength: matchIdentity.hash32.length,
          hashFirst8: Array.from(matchIdentity.hash32.slice(0, 8)).join(','),
          playerA: sortedA.toString(),
          playerB: sortedB.toString(),
        },
        instructionArgs: {
          matchIdHashArrayLength: matchIdHashArray.length,
          matchIdU64BN: matchIdU64BN.toString(),
          startTs: startTs,
        }
      })
      
      // Verify program ID before executing instruction
      if (this.program.programId.toString() !== PROGRAM_ID.toString()) {
        throw new Error(
          `Program ID mismatch before instruction execution. ` +
          `Program has ${this.program.programId.toString()}, expected ${PROGRAM_ID.toString()}. ` +
          `This will cause DeclaredProgramIdMismatch. Please rebuild and redeploy the program.`
        )
      }
      
      try {
        // Validate account order before passing to Anchor
        // The Rust constraint requires player_a.key() < player_b.key()
        // Anchor maps camelCase (playerA) to snake_case (player_a)
        const aBytes = sortedA.toBytes()
        const bBytes = sortedB.toBytes()
        let isValidOrder = false
        for (let i = 0; i < aBytes.length; i++) {
          if (aBytes[i] < bBytes[i]) {
            isValidOrder = true
            break
          }
          if (aBytes[i] > bBytes[i]) {
            throw new Error(
              `CRITICAL: Account order validation failed! ` +
              `sortedA (${sortedA.toString()}) > sortedB (${sortedB.toString()}) at byte ${i}. ` +
              `This will cause InvalidPlayerOrder error.`
            )
          }
        }
        
        if (!isValidOrder) {
          // This should never happen if the validation in MatchStartModal works correctly
          // But if it does, we need to fail fast and not attempt the transaction
          const error = new Error(
            `CRITICAL: Cannot create match - both players have the same wallet address! ` +
            `Both players: ${sortedA.toString()}. ` +
            `This is a configuration error - check that playerAWallet and playerBWallet are different.`
          )
          console.error('[DroogGameClient.initMatch]', error.message)
          throw error
        }
        
        console.log('[DroogGameClient.initMatch] Account order validated:', {
          playerA: sortedA.toString(),
          playerB: sortedB.toString(),
          playerAFirstByte: aBytes[0],
          playerBFirstByte: bBytes[0],
          isValid: isValidOrder,
        })
        
        // CRITICAL: Build instruction manually to ensure player_b is NOT a signer
        // Anchor's .rpc() might incorrectly infer player_b as a signer, so we build
        // the instruction explicitly and then send it with correct account metadata
        console.log('[DroogGameClient.initMatch] Building instruction with explicit account metadata...')
        
        // Build the instruction using Anchor's builder
        const instruction = await methods
          .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
          .accounts({
            // Don't pass matchState - Anchor will derive it
            // IMPORTANT: playerA maps to player_a in Rust, playerB maps to player_b
            // The Rust constraint requires player_a.key() < player_b.key()
            playerA: sortedA,
            playerB: sortedB,
            systemProgram: SystemProgram.programId,
          } as any)
          .instruction()
        
        // CRITICAL: Verify and fix account metadata to ensure player_b is NOT a signer
        // The IDL says player_b should NOT be a signer (UncheckedAccount in Rust)
        // Find player_b in the instruction keys and ensure isSigner is false
        let playerBIndex = -1
        for (let i = 0; i < instruction.keys.length; i++) {
          const key = instruction.keys[i]
          // player_b should be the third account (after matchState and playerA)
          // We'll identify it by checking if it matches sortedB
          if (key.pubkey.equals(sortedB)) {
            playerBIndex = i
            // CRITICAL FIX: Ensure player_b is NOT a signer
            if (key.isSigner) {
              console.warn('[DroogGameClient.initMatch] ⚠️ player_b was incorrectly marked as signer, fixing...')
              instruction.keys[i] = {
                ...key,
                isSigner: false,
              }
            }
            break
          }
        }
        
        if (playerBIndex === -1) {
          console.error('[DroogGameClient.initMatch] Could not find player_b in instruction keys')
          throw new Error('Failed to locate player_b account in instruction')
        }
        
        // Log the final account metadata for debugging
        console.log('[DroogGameClient.initMatch] Instruction account metadata:', {
          totalKeys: instruction.keys.length,
          matchState: {
            pubkey: instruction.keys[0].pubkey.toString(),
            isSigner: instruction.keys[0].isSigner,
            isWritable: instruction.keys[0].isWritable,
          },
          playerA: {
            pubkey: instruction.keys[1].pubkey.toString(),
            isSigner: instruction.keys[1].isSigner,
            isWritable: instruction.keys[1].isWritable,
          },
          playerB: {
            index: playerBIndex,
            pubkey: instruction.keys[playerBIndex].pubkey.toString(),
            isSigner: instruction.keys[playerBIndex].isSigner,
            isWritable: instruction.keys[playerBIndex].isWritable,
            expectedPubkey: sortedB.toString(),
            matches: instruction.keys[playerBIndex].pubkey.equals(sortedB),
          },
          allKeys: instruction.keys.map((k: any, i: number) => ({
            index: i,
            pubkey: k.pubkey.toString(),
            isSigner: k.isSigner,
            isWritable: k.isWritable,
          })),
        })
        
        // CRITICAL: Double-check player_b is NOT a signer before sending
        if (instruction.keys[playerBIndex].isSigner) {
          console.error('[DroogGameClient.initMatch] ❌ CRITICAL: player_b is still marked as signer after fix!')
          throw new Error('player_b cannot be a signer - this indicates a bug in the fix')
        }
        
        // Create transaction and send it
        const tx = new Transaction().add(instruction)
        const signature = await this.provider.sendAndConfirm(tx)
        
        console.log('[DroogGameClient.initMatch] ✓ Success with explicit account metadata')
        return signature
      } catch (error: any) {
        console.error('[DroogGameClient.initMatch] Auto-derive failed:', error.message)
        console.error('[DroogGameClient.initMatch] Error details:', {
          message: error.message,
          logs: error.logs,
          errorCode: error.error?.errorCode,
          programId: this.program.programId.toString(),
          expectedProgramId: PROGRAM_ID.toString(),
        })
        // Log the full error object to see what Anchor is comparing
        if (error.logs) {
          console.error('[DroogGameClient.initMatch] Transaction logs:', error.logs)
        }
        if (error.error?.errorCode?.code === 'DeclaredProgramIdMismatch') {
          console.error('[DroogGameClient.initMatch] DeclaredProgramIdMismatch detected!')
          console.error('[DroogGameClient.initMatch] This means the deployed program binary has a different declare_id! than expected.')
          console.error('[DroogGameClient.initMatch] Client expects:', PROGRAM_ID.toString())
          console.error('[DroogGameClient.initMatch] Program instance has:', this.program.programId.toString())
          console.error('[DroogGameClient.initMatch] Solution: Rebuild and redeploy the program with: anchor build && anchor deploy')
        }
        
        // Don't try fallback if accounts are identical - this is a configuration error
        if (error.message.includes('identical pubkeys') || error.message.includes('same wallet address')) {
          console.error('[DroogGameClient.initMatch] Skipping fallback - accounts are identical. This is a configuration error.')
          throw error
        }
        
        // Fallback: Try with explicit PDA
        console.log('[DroogGameClient.initMatch] Fallback: Using explicit PDA...')
        // Re-validate order for fallback (should already be validated, but double-check)
        const fallbackABytes = sortedA.toBytes()
        const fallbackBBytes = sortedB.toBytes()
        for (let i = 0; i < fallbackABytes.length; i++) {
          if (fallbackABytes[i] > fallbackBBytes[i]) {
            throw new Error(
              `CRITICAL: Account order validation failed in fallback! ` +
              `sortedA (${sortedA.toString()}) > sortedB (${sortedB.toString()}) at byte ${i}.`
            )
          }
          if (fallbackABytes[i] < fallbackBBytes[i]) {
            break // Order is correct
          }
        }
        
        try {
          // Build instruction manually to ensure player_b is NOT a signer
          const instruction = await methods
            .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
            .accounts({
              matchState: matchPDA, // Explicit PDA
              // IMPORTANT: Ensure same order as above - playerA < playerB
              playerA: sortedA,
              playerB: sortedB,
              systemProgram: SystemProgram.programId,
            } as any)
            .instruction()
          
          // CRITICAL: Verify and fix account metadata to ensure player_b is NOT a signer
          for (let i = 0; i < instruction.keys.length; i++) {
            const key = instruction.keys[i]
            if (key.pubkey.equals(sortedB)) {
              if (key.isSigner) {
                console.warn('[DroogGameClient.initMatch] ⚠️ Fallback: player_b was incorrectly marked as signer, fixing...')
                instruction.keys[i] = {
                  ...key,
                  isSigner: false,
                }
              }
              break
            }
          }
          
          // Create transaction and send it
          const tx = new Transaction().add(instruction)
          const signature = await this.provider.sendAndConfirm(tx)
          
          console.log('[DroogGameClient.initMatch] ✓ Success with explicit PDA fallback')
          return signature
        } catch (fallbackError: any) {
          console.error('[DroogGameClient.initMatch] All approaches failed. Last error:', fallbackError.message)
          console.error('[DroogGameClient.initMatch] Final error details:', {
            message: fallbackError.message,
            logs: fallbackError.logs,
            errorCode: fallbackError.error?.errorCode,
            programId: this.program.programId.toString(),
            expectedProgramId: PROGRAM_ID.toString(),
          })
          if (fallbackError.logs) {
            console.error('[DroogGameClient.initMatch] Final transaction logs:', fallbackError.logs)
          }
          if (fallbackError.error?.errorCode?.code === 'DeclaredProgramIdMismatch') {
            console.error('[DroogGameClient.initMatch] ⚠️ CRITICAL: DeclaredProgramIdMismatch error')
            console.error('[DroogGameClient.initMatch] The deployed program binary was compiled with a different declare_id!')
            console.error('[DroogGameClient.initMatch] Expected program ID:', PROGRAM_ID.toString())
            console.error('[DroogGameClient.initMatch] Program instance ID:', this.program.programId.toString())
            console.error('[DroogGameClient.initMatch]')
            console.error('[DroogGameClient.initMatch] To fix this:')
            console.error('[DroogGameClient.initMatch] 1. Ensure programs/droog-game/src/lib.rs has: declare_id!("' + PROGRAM_ID.toString() + '")')
            console.error('[DroogGameClient.initMatch] 2. Run: anchor keys sync')
            console.error('[DroogGameClient.initMatch] 3. Run: anchor build')
            console.error('[DroogGameClient.initMatch] 4. Run: anchor deploy --provider.cluster devnet')
          }
          throw fallbackError
        }
      }
    } catch (error: any) {
      // If we get InstructionFallbackNotFound, the IDL might be out of sync
      const errorMessage = error?.message || error?.toString() || ''
      if (errorMessage.includes('InstructionFallbackNotFound') || errorMessage.includes('101')) {
        console.error('[DroogGameClient.initMatch] InstructionFallbackNotFound error - IDL may be out of sync')
        console.error('[DroogGameClient.initMatch] Program ID:', this.program.programId.toString())
        console.error('[DroogGameClient.initMatch] IDL instructions:', idl.instructions.map((ix: any) => ({
          name: ix.name,
          discriminator: ix.discriminator ? Array.from(ix.discriminator) : 'missing',
        })))
        
        // Try to fetch IDL from chain and recreate the client
        console.warn('[DroogGameClient.initMatch] Attempting to fetch IDL from chain...')
        try {
          const chainIdl = await DroogGameClient.fetchIdlFromChain(this.connection, this.program.programId)
          if (chainIdl) {
            // Normalize the fetched IDL
            const cloned = deepCloneIdl(chainIdl)
            // Ensure the IDL address matches the actual program ID
            cloned.address = PROGRAM_ID.toString()
            const normalizedIdl = await normalizeIdl(cloned)
            
            // Recreate the program with the fetched IDL
            const idlWithoutEvents = { ...normalizedIdl }
            // Ensure address is set (normalizeIdl might not preserve it)
            idlWithoutEvents.address = PROGRAM_ID.toString()
            const originalEvents = idlWithoutEvents.events
            delete idlWithoutEvents.events
            
            this.program = new Program(idlWithoutEvents as any, this.provider)
            
            if (originalEvents && this.program.idl) {
              this.program.idl.events = originalEvents
            }
            
            console.log('[DroogGameClient.initMatch] Recreated program with IDL from chain, retrying...')
            
            // Retry the call with the new program
            const retryMethods = this.program.methods as any
            const tx = await retryMethods
              .initMatch(matchIdHashArray, matchIdU64BN, new BN(startTs))
              .accounts({
                matchState: matchPDA,
                playerA: sortedA,
                playerB: sortedB,
                systemProgram: SystemProgram.programId,
              })
              .rpc()
            
            return tx
          }
        } catch (fetchError) {
          console.error('[DroogGameClient.initMatch] Failed to fetch IDL from chain:', fetchError)
        }
        
        throw new Error(
          'InstructionFallbackNotFound: The program IDL may be out of sync with the deployed program. ' +
          'Please rebuild and redeploy the program, or ensure the IDL is up to date.'
        )
      }
      throw error
    }
  }

  /**
   * Check if Match PDA exists on-chain.
   * Used for polling when waiting for the other player to create the PDA.
   * 
   * @param matchIdString - The string matchId
   * @param playerA - First player's public key
   * @param playerB - Second player's public key
   * @param commitment - Commitment level for the fetch (defaults to 'confirmed' for faster reads)
   * @returns Promise resolving to MatchState if PDA exists, null otherwise
   */
  async checkMatchPDAExists(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    commitment: 'processed' | 'confirmed' | 'finalized' = 'confirmed'
  ): Promise<MatchState | null> {
    try {
      // Use canonical match identity for consistency
      const matchIdentity = await createMatchIdentity(matchIdString)
      const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
        matchIdentity.hash32,
        playerA,
        playerB
      )

      const account = await (this.program.account as any).matchState.fetch(matchPDA, commitment)
      
      return {
        matchId: account.matchId,
        startTs: account.startTs,
        endTs: account.endTs,
        playerA: account.playerA,
        playerB: account.playerB,
        customers: account.customers.map((c: any) => ({
          layer: c.layer,
          lastServedTs: c.lastServedTs,
          totalServes: c.totalServes,
          lastServedBy: c.lastServedBy,
        })),
        playerASales: account.playerASales.toNumber ? account.playerASales.toNumber() : account.playerASales,
        playerBSales: account.playerBSales.toNumber ? account.playerBSales.toNumber() : account.playerBSales,
        playerAReputation: account.playerAReputation.toNumber ? account.playerAReputation.toNumber() : account.playerAReputation,
        playerBReputation: account.playerBReputation.toNumber ? account.playerBReputation.toNumber() : account.playerBReputation,
        isFinalized: account.isFinalized,
      }
    } catch (error) {
      // PDA doesn't exist yet
      return null
    }
  }

  /**
   * Get player pubkeys from an existing match.
   * Helper to extract both player pubkeys from match state.
   * 
   * @param matchIdString - The string matchId
   * @param playerA - First player's public key (for PDA derivation)
   * @param playerB - Second player's public key (for PDA derivation)
   * @returns Promise resolving to [playerA, playerB] pubkeys from on-chain state
   */
  async getPlayerPubkeysFromMatch(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<[PublicKey, PublicKey] | null> {
    const matchState = await this.checkMatchPDAExists(matchIdString, playerA, playerB)
    if (!matchState) {
      return null
    }
    return [matchState.playerA, matchState.playerB]
  }

  /**
   * Initialize grow state for a match
   * Should be called after initMatch
   */
  async initGrowState(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1458',message:'initGrowState entry',data:{matchIdString,playerA:playerA.toBase58(),playerB:playerB.toBase58()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const payer = this.provider.wallet.publicKey
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1472',message:'initGrowState before tx',data:{matchPDA:matchPDA.toBase58(),growStatePDA:growStatePDA.toBase58(),payer:payer.toBase58(),matchId:matchIdentity.u64.toString()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion

    try {
    const tx = await (this.program.methods as any)
      .initGrowState(Array.from(matchIdentity.hash32), matchIdentity.u64)
      .accounts({
        growState: growStatePDA,
        matchState: matchPDA,
        payer,
        systemProgram: SystemProgram.programId,
      })
      .rpc()
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1482',message:'initGrowState succeeded',data:{txSignature:tx},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion

    return tx
    } catch (error: any) {
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1485',message:'initGrowState failed',data:{errorMessage:error?.message,errorCode:error?.error?.errorCode,logs:error?.logs,transactionLogs:error?.transactionLogs},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      throw error
    }
  }

  /**
   * Initialize delivery state for a match
   * Should be called after initMatch, before gameplay begins
   * 
   * Authority: Solana ONLY
   * - Delivery spots are selected deterministically
   * - Client cannot influence initial selection
   */
  async initDeliveryState(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchIdentity.u64)
    const payer = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .initDeliveryState(Array.from(matchIdentity.hash32), matchIdentity.u64)
      .accounts({
        deliveryState: deliveryStatePDA,
        matchState: matchPDA,
        payer,
        systemProgram: SystemProgram.programId,
      })
      .rpc()

    return tx
  }

  /**
   * Refresh delivery slots after 60-second rotation interval
   * 
   * Permissionless: Anyone can call this, but it only succeeds if:
   * - 60 seconds have passed since last refresh
   * - Match is still active
   * 
   * Authority: Solana ONLY
   * - Selection is purely deterministic from match_id + timestamp bucket
   */
  async refreshDeliverySlots(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchIdentity.u64)

    const tx = await (this.program.methods as any)
      .refreshDeliverySlots()
      .accounts({
        deliveryState: deliveryStatePDA,
        matchState: matchPDA,
      })
      .rpc()

    return tx
  }

  /**
   * Plant a strain in a grow slot
   * Automatically initializes grow state if it doesn't exist
   */
  async plantStrain(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    slotIndex: number,
    strainLevel: number
  ): Promise<string> {
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1558',message:'plantStrain entry',data:{matchIdString,playerA:playerA.toBase58(),playerB:playerB.toBase58(),slotIndex,strainLevel},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E'})}).catch(()=>{});
    // #endregion
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const player = this.provider.wallet.publicKey

    // Check if grow state account exists
    let growStateAccountInfo = await this.provider.connection.getAccountInfo(growStatePDA)
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1570',message:'growState account check',data:{growStatePDA:growStatePDA.toBase58(),exists:!!growStateAccountInfo,owner:growStateAccountInfo?.owner?.toBase58(),dataLength:growStateAccountInfo?.data?.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
    // #endregion
    
    // If grow state doesn't exist, initialize it first
    if (!growStateAccountInfo) {
      console.log('[DroogGameClient] Grow state not initialized, initializing now...')
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1575',message:'calling initGrowState',data:{matchIdString,playerA:playerA.toBase58(),playerB:playerB.toBase58()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,E'})}).catch(()=>{});
      // #endregion
      try {
        await this.initGrowState(matchIdString, playerA, playerB)
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1577',message:'initGrowState succeeded',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        console.log('[DroogGameClient] Grow state initialized successfully')
      } catch (initError: any) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1579',message:'initGrowState failed',data:{error:initError?.message,logs:initError?.logs,errorCode:initError?.error?.errorCode},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        throw initError
      }
      // Re-fetch after initialization
      growStateAccountInfo = await this.provider.connection.getAccountInfo(growStatePDA)
    }

    // Fetch grow state to get the actual player_a and player_b stored on-chain
    // The plant_strain instruction derives match_state from grow_state, so we need
    // to use the same player order that's stored in grow_state
    const growState = await this.getGrowState(matchIdentity.u64)
    if (!growState) {
      throw new Error('Grow state account exists but could not be fetched')
    }
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1584',message:'growState fetched',data:{matchId:growState.matchId,playerA:typeof growState.playerA==='string'?growState.playerA:growState.playerA.toBase58(),playerB:typeof growState.playerB==='string'?growState.playerB:growState.playerB.toBase58()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion

    // Derive match_state PDA using the players stored in grow_state
    // This ensures the PDA matches what the Rust instruction expects
    const growStatePlayerA = typeof growState.playerA === 'string' 
      ? new PublicKey(growState.playerA)
      : growState.playerA
    const growStatePlayerB = typeof growState.playerB === 'string'
      ? new PublicKey(growState.playerB)
      : growState.playerB
    
    // Get match_id_hash from grow_state (we need to fetch the raw account for this)
    // Actually, we can derive it from the matchIdentity.hash32 which should match
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      growStatePlayerA,
      growStatePlayerB
    )
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1604',message:'PDAs derived',data:{matchPDA:matchPDA.toBase58(),growStatePDA:growStatePDA.toBase58(),growStatePlayerA:growStatePlayerA.toBase58(),growStatePlayerB:growStatePlayerB.toBase58(),clientPlayerA:playerA.toBase58(),clientPlayerB:playerB.toBase58()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion

    // Verify match_state account exists
    const matchStateAccountInfo = await this.provider.connection.getAccountInfo(matchPDA)
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1607',message:'matchState account check',data:{matchPDA:matchPDA.toBase58(),exists:!!matchStateAccountInfo,owner:matchStateAccountInfo?.owner?.toBase58()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion

    try {
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1610',message:'before transaction construction',data:{slotIndex,strainLevel,player:player.toBase58(),growStatePDA:growStatePDA.toBase58(),matchPDA:matchPDA.toBase58()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C,D,E'})}).catch(()=>{});
      // #endregion
    const tx = await (this.program.methods as any)
      .plantStrain(slotIndex, strainLevel)
      .accounts({
        growState: growStatePDA,
        matchState: matchPDA,
        player,
      })
      .rpc()
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1616',message:'transaction succeeded',data:{txSignature:tx},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E'})}).catch(()=>{});
      // #endregion

    return tx
    } catch (error: any) {
      // Enhanced error logging for debugging
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/987a5869-dff7-42fa-b5cf-a1057d98fb5e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solanaClient.ts:1620',message:'transaction error caught',data:{errorMessage:error?.message,errorCode:error?.error?.errorCode,errorNumber:error?.error?.errorNumber,logs:error?.logs,programErrorStack:error?.programErrorStack,transactionLogs:error?.transactionLogs},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D'})}).catch(()=>{});
      // #endregion
      console.error('[DroogGameClient.plantStrain] Transaction failed:', {
        error: error.message,
        logs: error.logs,
        errorCode: error.error?.errorCode,
        programErrorStack: error.programErrorStack,
        slotIndex,
        strainLevel,
        player: player.toBase58(),
        matchPDA: matchPDA.toBase58(),
        growStatePDA: growStatePDA.toBase58(),
        clientPlayerA: playerA.toBase58(),
        clientPlayerB: playerB.toBase58(),
        growStatePlayerA: growStatePlayerA.toBase58(),
        growStatePlayerB: growStatePlayerB.toBase58(),
      })
      
      // Log transaction logs if available
      if (error.logs) {
        console.error('[DroogGameClient.plantStrain] Transaction logs:')
        error.logs.forEach((log: string) => console.error('  ', log))
      }
      
      throw error
    }
  }

  /**
   * Harvest a ready plant from a grow slot
   */
  async harvestStrain(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    slotIndex: number
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const player = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .harvestStrain(slotIndex)
      .accounts({
        growState: growStatePDA,
        matchState: matchPDA,
        player,
      })
      .rpc()

    return tx
  }

  /**
   * Legacy harvest instruction (kept for backwards compatibility)
   * @deprecated Use harvestStrain instead
   */
  async harvest(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    strainId: number,
    plantedAt: number,
    lastHarvestedAt: number | null
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const player = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .harvest(
        strainId,
        new BN(plantedAt),
        lastHarvestedAt !== null ? new BN(lastHarvestedAt) : null
      )
      .accounts({
        matchState: matchPDA,
        player,
      })
      .rpc()

    return tx
  }

  /**
   * Sell to a customer
   * Requires grow state for inventory management AND delivery state for availability validation
   * 
   * Authority: Solana ONLY
   * - Validates customer is in current delivery rotation
   * - Client cannot bypass availability check
   */
  async sellToCustomer(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey,
    customerIndex: number,
    strainLevel: number
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchIdentity.u64)
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchIdentity.u64)
    const player = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .sellToCustomer(customerIndex, strainLevel)
      .accounts({
        matchState: matchPDA,
        growState: growStatePDA,
        deliveryState: deliveryStatePDA,
        player,
      })
      .rpc()

    return tx
  }

  /**
   * Finalize a match after it has ended
   * Can only be called once, after end_ts, by a match participant
   */
  async finalizeMatch(
    matchIdString: string,
    playerA: PublicKey,
    playerB: PublicKey
  ): Promise<string> {
    const matchIdentity = await createMatchIdentity(matchIdString)
    const [matchPDA] = DroogGameClient.deriveMatchPDAFromHash(
      matchIdentity.hash32,
      playerA,
      playerB
    )
    const player = this.provider.wallet.publicKey

    const tx = await (this.program.methods as any)
      .finalizeMatch()
      .accounts({
        matchState: matchPDA,
        player,
      })
      .rpc()

    return tx
  }

  /**
   * Fetch match state
   */
  async getMatchState(matchId: number): Promise<MatchState | null> {
    try {
      const [matchPDA] = DroogGameClient.deriveMatchPDA(matchId)
      const account = await (this.program.account as any).matchState.fetch(matchPDA)
      
        return {
          matchId: account.matchId,
          startTs: account.startTs,
          endTs: account.endTs,
          playerA: account.playerA,
          playerB: account.playerB,
          customers: account.customers.map((c: any) => ({
            layer: c.layer,
            lastServedTs: c.lastServedTs,
            totalServes: c.totalServes,
            lastServedBy: c.lastServedBy,
          })),
          playerASales: account.playerASales.toNumber ? account.playerASales.toNumber() : account.playerASales,
          playerBSales: account.playerBSales.toNumber ? account.playerBSales.toNumber() : account.playerBSales,
          playerAReputation: account.playerAReputation.toNumber ? account.playerAReputation.toNumber() : account.playerAReputation,
          playerBReputation: account.playerBReputation.toNumber ? account.playerBReputation.toNumber() : account.playerBReputation,
          isFinalized: account.isFinalized,
        }
    } catch (error) {
      console.error('Error fetching match state:', error)
      return null
    }
  }

  /**
   * Fetch grow state
   */
  async getGrowState(matchId: number | BN | bigint): Promise<GrowState | null> {
    try {
      const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchId)
      const account = await (this.program.account as any).matchGrowState.fetch(growStatePDA)
      
      const parseSlot = (slot: any): GrowSlot => {
        // Parse the new PlantState enum structure
        // Anchor serializes enums as objects with __kind field (or discriminator)
        // Handle both possible formats
        let plantState: PlantState
        if (slot.plantState) {
          // Check if it's already in the expected format
          if (slot.plantState.__kind) {
            plantState = slot.plantState
          } else if (slot.plantState.discriminator !== undefined) {
            // Alternative format: use discriminator
            const disc = slot.plantState.discriminator
            if (disc === 0) {
              plantState = { __kind: 'Empty' }
            } else if (disc === 1) {
              plantState = { 
                __kind: 'Growing', 
                strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || 0,
                plantedAt: slot.plantState.plantedAt || slot.plantState.planted_at || new BN(0)
              }
            } else if (disc === 2) {
              plantState = { 
                __kind: 'Ready', 
                strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || 0
              }
            } else {
              plantState = { __kind: 'Empty' }
            }
          } else {
            // Try to infer from structure
            if ('plantedAt' in slot.plantState || 'planted_at' in slot.plantState) {
              plantState = {
                __kind: 'Growing',
                strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || slot.strainLevel || 0,
                plantedAt: slot.plantState.plantedAt || slot.plantState.planted_at || new BN(0)
              }
            } else if ('strainLevel' in slot.plantState || 'strain_level' in slot.plantState) {
              plantState = {
                __kind: 'Ready',
                strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || slot.strainLevel || 0
              }
            } else {
              plantState = { __kind: 'Empty' }
            }
          }
        } else {
          // No plantState field - might be legacy format or truly empty
          plantState = { __kind: 'Empty' }
        }
        
        // Extract values based on plant state
        let occupied = false
        let plantedTs: BN = new BN(0)
        let readyTs: BN = new BN(0)
        let harvested = false
        
        if (plantState.__kind === 'Growing') {
          occupied = true
          const plantedAt = plantState.plantedAt
          plantedTs = typeof plantedAt === 'number' 
            ? new BN(plantedAt) 
            : (plantedAt instanceof BN ? plantedAt : new BN(plantedAt))
          // Calculate readyTs from planted_at + growth_time
          const growthTime = GROWTH_TIMES[plantState.strainLevel as 1 | 2 | 3] || 0
          readyTs = plantedTs.add(new BN(growthTime))
        } else if (plantState.__kind === 'Ready') {
          occupied = true
          // For Ready state, we don't have planted_at anymore
          // Calculate backwards: if it's ready now, planted_at was (current_time - growth_time)
          // But we don't have current_time here, so we'll set readyTs to 0 (meaning "already ready")
          // The UI will handle this by checking if currentTs >= readyTs (which will always be true)
          plantedTs = new BN(0)
          readyTs = new BN(0) // Set to 0 to indicate "already ready"
        } else {
          // Empty state - slot is available for planting
          occupied = false
          plantedTs = new BN(0)
          readyTs = new BN(0)
          harvested = false
        }
        
        const parsedSlot: GrowSlot = {
          // New structure
          plantState,
          strainLevel: slot.strainLevel || 0,
          variantId: slot.variantId || 0,
          lastHarvestedTs: slot.lastHarvestedTs 
            ? (typeof slot.lastHarvestedTs === 'number' 
                ? new BN(slot.lastHarvestedTs) 
                : (slot.lastHarvestedTs instanceof BN ? slot.lastHarvestedTs : new BN(slot.lastHarvestedTs)))
            : new BN(0),
          
          // Legacy fields for backward compatibility
          occupied,
          plantedTs,
          readyTs,
          harvested,
        }
        
        return parsedSlot
      }

      const parseInventory = (inv: any): Inventory => ({
        level1: inv.level1,
        level2: inv.level2,
        level3: inv.level3,
      })

      return {
        matchId: account.matchId,
        playerA: account.playerA,
        playerB: account.playerB,
        playerASlots: account.playerASlots.map(parseSlot),
        playerBSlots: account.playerBSlots.map(parseSlot),
        playerAInventory: parseInventory(account.playerAInventory),
        playerBInventory: parseInventory(account.playerBInventory),
      }
    } catch (error) {
      console.error('Error fetching grow state:', error)
      return null
    }
  }

  /**
   * Fetch delivery state
   * 
   * Returns the current on-chain delivery availability state.
   * This is the AUTHORITATIVE source of which customers are available.
   */
  async getDeliveryState(matchId: number): Promise<DeliveryState | null> {
    try {
      const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchId)
      const account = await (this.program.account as any).matchDeliveryState.fetch(deliveryStatePDA)
      
      // Filter out invalid indices (255)
      const availableCustomers: number[] = []
      for (let i = 0; i < account.activeCount; i++) {
        const idx = account.availableCustomers[i]
        if (idx !== 255) {
          availableCustomers.push(idx)
        }
      }

      return {
        matchId: account.matchId,
        lastUpdateTs: account.lastUpdateTs,
        availableCustomers,
        activeCount: account.activeCount,
      }
    } catch (error) {
      console.error('Error fetching delivery state:', error)
      return null
    }
  }

  /**
   * Check if customer is available (cooldown passed)
   * Uses match-anchored time to prevent clock drift issues
   */
  async isCustomerAvailable(matchId: number, customerIndex: number): Promise<boolean> {
    const matchState = await this.getMatchState(matchId)
    if (!matchState) return false

    const customer = matchState.customers[customerIndex]
    if (!customer) return false

    // If never served, available
    if (customer.lastServedTs.toNumber() === 0) return true

    // Check cooldown using match-anchored time
    const cooldowns = [30, 45, 75] // Layer 1, 2, 3 in seconds
    const cooldown = cooldowns[customer.layer - 1] || 0
    const matchStartTs = matchState.startTs.toNumber()
    const currentTs = getCurrentMatchTime(matchStartTs)
    const timeSinceLastServe = currentTs - customer.lastServedTs.toNumber()

    return timeSinceLastServe >= cooldown
  }

  /**
   * Check if planting is allowed (not in endgame lock)
   */
  canPlant(matchStartTs: number, matchEndTs: number, currentTs?: number): boolean {
    const now = currentTs ?? getCurrentMatchTime(matchStartTs)
    return now < matchEndTs - ENDGAME_LOCK_SECONDS
  }

  /**
   * Check if a plant will be ready before match ends
   */
  willBeReadyInTime(
    matchEndTs: number,
    strainLevel: 1 | 2 | 3,
    currentTs: number
  ): boolean {
    const growthTime = GROWTH_TIMES[strainLevel]
    const readyTs = currentTs + growthTime
    return readyTs <= matchEndTs
  }

  /**
   * Compute smell for a player's slots (client-side, for UI only)
   */
  computeSmell(slots: GrowSlot[], currentTs: number): number {
    return slots
      .filter(s => s.occupied && !s.harvested)
      .reduce((total, slot) => {
        const plantedTs = slot.plantedTs.toNumber ? slot.plantedTs.toNumber() : slot.plantedTs
        const elapsedSecs = Math.max(0, currentTs - plantedTs)
        const elapsedMins = Math.floor(elapsedSecs / 60)
        const rate = SMELL_RATES[slot.strainLevel as 1 | 2 | 3] || 0
        return total + (elapsedMins * rate)
      }, 0)
  }

  /**
   * Subscribe to match state changes
   */
  subscribeToMatchState(
    matchId: number,
    callback: (matchState: MatchState | null) => void
  ): number {
    const [matchPDA] = DroogGameClient.deriveMatchPDA(matchId)
    
    const subscriptionId = this.connection.onAccountChange(
      matchPDA,
      (accountInfo) => {
        try {
          const matchState = this.program.coder.accounts.decode(
            'matchState',
            accountInfo.data
          ) as any
          
          callback({
            matchId: matchState.matchId,
            startTs: matchState.startTs,
            endTs: matchState.endTs,
            playerA: matchState.playerA,
            playerB: matchState.playerB,
            customers: matchState.customers.map((c: any) => ({
              layer: c.layer,
              lastServedTs: c.lastServedTs,
              totalServes: c.totalServes,
              lastServedBy: c.lastServedBy,
            })),
            playerASales: matchState.playerASales.toNumber ? matchState.playerASales.toNumber() : matchState.playerASales,
            playerBSales: matchState.playerBSales.toNumber ? matchState.playerBSales.toNumber() : matchState.playerBSales,
            playerAReputation: matchState.playerAReputation.toNumber ? matchState.playerAReputation.toNumber() : matchState.playerAReputation,
            playerBReputation: matchState.playerBReputation.toNumber ? matchState.playerBReputation.toNumber() : matchState.playerBReputation,
            isFinalized: matchState.isFinalized,
          })
        } catch (error) {
          console.error('Error decoding match state:', error)
          callback(null)
        }
      },
      'confirmed'
    )

    return subscriptionId
  }

  /**
   * Subscribe to grow state changes
   */
  subscribeToGrowState(
    matchId: number | BN | bigint,
    callback: (growState: GrowState | null) => void
  ): number {
    const [growStatePDA] = DroogGameClient.deriveGrowStatePDA(matchId)
    
    const subscriptionId = this.connection.onAccountChange(
      growStatePDA,
      (accountInfo) => {
        try {
          const growState = this.program.coder.accounts.decode(
            'matchGrowState',
            accountInfo.data
          ) as any
          
          const parseSlot = (slot: any): GrowSlot => {
            // Parse the new PlantState enum structure
            // Anchor serializes enums as objects with __kind field (or discriminator)
            // Handle both possible formats
            let plantState: PlantState
            if (slot.plantState) {
              // Check if it's already in the expected format
              if (slot.plantState.__kind) {
                plantState = slot.plantState
              } else if (slot.plantState.discriminator !== undefined) {
                // Alternative format: use discriminator
                const disc = slot.plantState.discriminator
                if (disc === 0) {
                  plantState = { __kind: 'Empty' }
                } else if (disc === 1) {
                  plantState = { 
                    __kind: 'Growing', 
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || 0,
                    plantedAt: slot.plantState.plantedAt || slot.plantState.planted_at || new BN(0)
                  }
                } else if (disc === 2) {
                  plantState = { 
                    __kind: 'Ready', 
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || 0
                  }
                } else {
                  plantState = { __kind: 'Empty' }
                }
              } else {
                // Try to infer from structure
                if ('plantedAt' in slot.plantState || 'planted_at' in slot.plantState) {
                  plantState = {
                    __kind: 'Growing',
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || slot.strainLevel || 0,
                    plantedAt: slot.plantState.plantedAt || slot.plantState.planted_at || new BN(0)
                  }
                } else if ('strainLevel' in slot.plantState || 'strain_level' in slot.plantState) {
                  plantState = {
                    __kind: 'Ready',
                    strainLevel: slot.plantState.strainLevel || slot.plantState.strain_level || slot.strainLevel || 0
                  }
                } else {
                  plantState = { __kind: 'Empty' }
                }
              }
            } else {
              // No plantState field - might be legacy format or truly empty
              plantState = { __kind: 'Empty' }
            }
            
            // Extract values based on plant state
            let occupied = false
            let plantedTs: BN = new BN(0)
            let readyTs: BN = new BN(0)
            let harvested = false
            
            if (plantState.__kind === 'Growing') {
              occupied = true
              const plantedAt = plantState.plantedAt
              plantedTs = typeof plantedAt === 'number' 
                ? new BN(plantedAt) 
                : (plantedAt instanceof BN ? plantedAt : new BN(plantedAt))
              // Calculate readyTs from planted_at + growth_time
              const growthTime = GROWTH_TIMES[plantState.strainLevel as 1 | 2 | 3] || 0
              readyTs = plantedTs.add(new BN(growthTime))
            } else if (plantState.__kind === 'Ready') {
              occupied = true
              plantedTs = new BN(0)
              readyTs = new BN(0) // Set to 0 to indicate "already ready"
            } else {
              // Empty state
              occupied = false
              plantedTs = new BN(0)
              readyTs = new BN(0)
              harvested = false
            }
            
            return {
              // New structure
              plantState,
              strainLevel: slot.strainLevel || 0,
              variantId: slot.variantId || 0,
              lastHarvestedTs: slot.lastHarvestedTs 
                ? (typeof slot.lastHarvestedTs === 'number' 
                    ? new BN(slot.lastHarvestedTs) 
                    : (slot.lastHarvestedTs instanceof BN ? slot.lastHarvestedTs : new BN(slot.lastHarvestedTs)))
                : new BN(0),
              
              // Legacy fields for backward compatibility
              occupied,
              plantedTs,
              readyTs,
              harvested,
            }
          }

          const parseInventory = (inv: any): Inventory => ({
            level1: inv.level1,
            level2: inv.level2,
            level3: inv.level3,
          })

          callback({
            matchId: growState.matchId,
            playerA: growState.playerA,
            playerB: growState.playerB,
            playerASlots: growState.playerASlots.map(parseSlot),
            playerBSlots: growState.playerBSlots.map(parseSlot),
            playerAInventory: parseInventory(growState.playerAInventory),
            playerBInventory: parseInventory(growState.playerBInventory),
          })
        } catch (error) {
          console.error('Error decoding grow state:', error)
          callback(null)
        }
      },
      'confirmed'
    )

    return subscriptionId
  }

  /**
   * Subscribe to delivery state changes
   * 
   * This allows the client to react to on-chain delivery rotations.
   * The on-chain state is AUTHORITATIVE.
   */
  subscribeToDeliveryState(
    matchId: number,
    callback: (deliveryState: DeliveryState | null) => void
  ): number {
    const [deliveryStatePDA] = DroogGameClient.deriveDeliveryStatePDA(matchId)
    
    const subscriptionId = this.connection.onAccountChange(
      deliveryStatePDA,
      (accountInfo) => {
        try {
          const deliveryState = this.program.coder.accounts.decode(
            'matchDeliveryState',
            accountInfo.data
          ) as any
          
          // Filter out invalid indices (255)
          const availableCustomers: number[] = []
          for (let i = 0; i < deliveryState.activeCount; i++) {
            const idx = deliveryState.availableCustomers[i]
            if (idx !== 255) {
              availableCustomers.push(idx)
            }
          }

          callback({
            matchId: deliveryState.matchId,
            lastUpdateTs: deliveryState.lastUpdateTs,
            availableCustomers,
            activeCount: deliveryState.activeCount,
          })
        } catch (error) {
          console.error('Error decoding delivery state:', error)
          callback(null)
        }
      },
      'confirmed'
    )

    return subscriptionId
  }

  /**
   * Unsubscribe from match state changes
   */
  unsubscribeFromMatchState(subscriptionId: number): Promise<void> {
    return this.connection.removeAccountChangeListener(subscriptionId)
  }

  /**
   * Unsubscribe from grow state changes
   */
  unsubscribeFromGrowState(subscriptionId: number): Promise<void> {
    return this.connection.removeAccountChangeListener(subscriptionId)
  }

  /**
   * Unsubscribe from delivery state changes
   */
  unsubscribeFromDeliveryState(subscriptionId: number): Promise<void> {
    return this.connection.removeAccountChangeListener(subscriptionId)
  }

  /**
   * Check if a customer is currently available for delivery
   * 
   * Uses on-chain delivery state (AUTHORITATIVE).
   * This is different from cooldown availability.
   */
  async isCustomerAvailableForDelivery(matchId: number, customerIndex: number): Promise<boolean> {
    const deliveryState = await this.getDeliveryState(matchId)
    if (!deliveryState) return false
    return deliveryState.availableCustomers.includes(customerIndex)
  }
}

/**
 * Create a wallet from a keypair or signer
 */
export function createWalletFromKeypair(keypair: any): Wallet {
  return {
    publicKey: keypair.publicKey,
    signTransaction: async <T extends Transaction>(tx: T): Promise<T> => {
      (tx as Transaction).sign(keypair)
      return tx
    },
    signAllTransactions: async <T extends Transaction>(txs: T[]): Promise<T[]> => {
      txs.forEach(tx => (tx as Transaction).sign(keypair))
      return txs
    },
  } as Wallet
}

/**
 * Create a wallet from a Privy Solana wallet
 * Ensures proper structure for Anchor's Wallet interface
 * 
 * This is critical for Privy integration - Privy wallets have a different
 * structure than standard Solana wallets and must be wrapped correctly.
 * 
 * @param privyWallet - The Privy wallet from useWallets() hook
 * @param signTransactionFn - The signTransaction function from useSignTransaction() hook (REQUIRED)
 * @param signAllTransactionsFn - Optional signAllTransactions function from useSignAllTransactions() hook
 */
export function createWalletFromPrivyWallet(
  privyWallet: {
    address: string
  },
  signTransactionFn: (input: {
    transaction: Uint8Array | Transaction
    wallet: any
    chain?: string // Optional chain parameter (e.g., 'solana:devnet')
  }) => Promise<{ signedTransaction: Uint8Array }>,
  signAllTransactionsFn?: (input: {
    transactions: (Uint8Array | Transaction)[]
    wallet: any
    chain?: string // Optional chain parameter (e.g., 'solana:devnet')
  }) => Promise<{ signedTransactions: Uint8Array[] }>
): Wallet {
  if (!privyWallet.address) {
    throw new Error('Privy wallet address is required')
  }
  
  // Validate address is a valid Solana public key
  let publicKey: PublicKey
  try {
    publicKey = new PublicKey(privyWallet.address)
  } catch (error) {
    throw new Error(`Invalid Solana public key: ${privyWallet.address}`)
  }
  
  // signTransactionFn is REQUIRED
  if (!signTransactionFn || typeof signTransactionFn !== 'function') {
    throw new Error(
      'signTransaction function from useSignTransaction() hook is required. ' +
      'Pass it as the second parameter to createWalletFromPrivyWallet().'
    )
  }

  // Debug logging
  console.log('[createWalletFromPrivyWallet] Wrapping Privy wallet:', {
    address: privyWallet.address,
    publicKey: publicKey.toString(),
    hasSignTransactionFn: typeof signTransactionFn === 'function',
    hasSignAllTransactionsFn: typeof signAllTransactionsFn === 'function',
  })
  
  // Create Anchor-compatible wallet wrapper
  // Privy's signTransaction from useSignTransaction() hook expects:
  // { transaction: Uint8Array | Transaction, wallet: ConnectedStandardSolanaWallet }
  // and returns { signedTransaction: Uint8Array }
  const anchorWallet = {
    publicKey,
    signTransaction: async <T extends Transaction | VersionedTransaction>(tx: T): Promise<T> => {
      // Anchor primarily uses legacy Transaction objects, so we can safely cast
      if (!(tx instanceof Transaction)) {
        throw new Error('VersionedTransaction not supported with Privy wallet - Anchor uses legacy Transaction')
      }
      const legacyTx = tx as Transaction
      try {
        // Ensure transaction has required fields before signing
        if (!legacyTx.recentBlockhash) {
          throw new Error('Transaction missing recentBlockhash - this should be set by Anchor')
        }
        if (!legacyTx.feePayer) {
          legacyTx.feePayer = publicKey
        }
        
        // Serialize the transaction to Uint8Array before passing to Privy
        // Privy's signTransaction expects Uint8Array (its internal code calls bytes.slice())
        const serialized = legacyTx.serialize({
          requireAllSignatures: false,
          verifySignatures: false,
        })
        
        // Call Privy's signTransaction hook function
        // It expects { transaction: Uint8Array, wallet: ConnectedStandardSolanaWallet, chain: string }
        // CRITICAL: Must specify chain to use devnet, otherwise Privy defaults to mainnet
        const result = await signTransactionFn({
          transaction: new Uint8Array(serialized),
          wallet: privyWallet,
          chain: 'solana:devnet', // Explicitly use devnet network
        })
        
        // Privy's signTransaction returns { signedTransaction: Uint8Array }
        const signedBytes = result.signedTransaction
        
        // Deserialize the signed transaction back to a Transaction object
        const signedTx = Transaction.from(signedBytes)
        return signedTx as T
      } catch (error) {
        console.error('[createWalletFromPrivyWallet] Error signing transaction:', error)
        console.error('[createWalletFromPrivyWallet] Transaction details:', {
          recentBlockhash: legacyTx.recentBlockhash?.toString(),
          feePayer: legacyTx.feePayer?.toString(),
          instructions: legacyTx.instructions.length,
          signers: legacyTx.signatures.length,
        })
        throw error
      }
    },
    signAllTransactions: async <T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]> => {
      // Anchor primarily uses legacy Transaction objects
      // Type assertion needed because TypeScript can't narrow generic T
      const legacyTxs: Transaction[] = []
      for (const tx of txs) {
        if (tx instanceof Transaction) {
          legacyTxs.push(tx)
        } else {
          throw new Error('VersionedTransaction not supported with Privy wallet - Anchor uses legacy Transaction')
        }
      }
      
      try {
        // Use signAllTransactionsFn if provided
        if (signAllTransactionsFn && typeof signAllTransactionsFn === 'function') {
          // Serialize all transactions
          const serialized = legacyTxs.map(tx => 
            new Uint8Array(tx.serialize({
              requireAllSignatures: false,
              verifySignatures: false,
            }))
          )
          
          // Sign all transactions using Privy's signAllTransactions hook
          // CRITICAL: Must specify chain to use devnet, otherwise Privy defaults to mainnet
          const result = await signAllTransactionsFn({
            transactions: serialized,
            wallet: privyWallet,
            chain: 'solana:devnet', // Explicitly use devnet network
          })
          
          // Privy's signAllTransactions returns { signedTransactions: Uint8Array[] }
          const signedBytesArray = result.signedTransactions
          
          // Deserialize all signed transactions
          return signedBytesArray.map((bytes: Uint8Array) => 
            Transaction.from(bytes)
          ) as T[]
        }
        
        // Fallback: sign transactions sequentially using signTransaction
        // This is deterministic and preserves transaction order
        const signed: T[] = []
        for (const tx of legacyTxs) {
          const signedTx = await anchorWallet.signTransaction(tx)
          signed.push(signedTx as T)
        }
        return signed
      } catch (error) {
        console.error('[createWalletFromPrivyWallet] Error signing transactions:', error)
        throw error
      }
    },
  } as Wallet
  
  return anchorWallet
}
